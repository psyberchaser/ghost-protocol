\documentclass[11pt,a4paper]{article}

% Font setup - Inter (compile with XeLaTeX or LuaLaTeX)
% Installed via: brew install --cask font-inter
\usepackage{fontspec}

% Inter - clean, modern sans-serif
\setmainfont{Inter}[
  Scale = 0.95,
  BoldFont = Inter-Bold,
  ItalicFont = Inter-Italic,
  BoldItalicFont = Inter-BoldItalic
]
\setsansfont{Inter}[Scale = 0.95, BoldFont = Inter-Bold]
\setmonofont{Menlo}[Scale = 0.85]

\usepackage[margin=1in,headheight=14pt]{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}

\definecolor{backcolour}{rgb}{0.95,0.95,0.95}
\definecolor{ghostpurple}{RGB}{139,92,246}
\definecolor{ghostcyan}{RGB}{6,182,212}
\definecolor{ghostgreen}{RGB}{16,185,129}
\definecolor{ghostorange}{RGB}{249,115,22}
\definecolor{ghostred}{RGB}{239,68,68}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}

\lstdefinestyle{mystyle}{backgroundcolor=\color{backcolour},basicstyle=\ttfamily\small,breaklines=true,frame=single}
\lstset{style=mystyle}
\hypersetup{colorlinks=true,linkcolor=ghostpurple,urlcolor=ghostcyan}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textsc{Ghost Protocol}}
\fancyhead[R]{\textsc{Technical Documentation}}
\fancyfoot[C]{\thepage}
\titleformat{\section}{\Large\bfseries\color{ghostpurple}}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries\color{ghostcyan}}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries\color{ghostgreen}}{\thesubsubsection}{1em}{}

\newtcolorbox{infobox}[1][]{colback=backcolour,colframe=ghostpurple,fonttitle=\bfseries,title=#1}
\newtcolorbox{warningbox}[1][]{colback=yellow!5,colframe=ghostorange,fonttitle=\bfseries,title=#1}
\newtcolorbox{dangerbox}[1][]{colback=red!5,colframe=ghostred,fonttitle=\bfseries,title=#1}
\newtcolorbox{successbox}[1][]{colback=green!5,colframe=ghostgreen,fonttitle=\bfseries,title=#1}
\newtcolorbox{archbox}{colback=backcolour,colframe=codegray}

\begin{document}

\begin{titlepage}
\centering
\vspace*{2cm}
{\Huge\bfseries\color{ghostpurple} Ghost Protocol\par}
\vspace{0.5cm}
{\LARGE Technical Documentation\par}
\vspace{1.5cm}
{\Large Trustless, Chain-Agnostic Cross-Chain Payment System\par}
\vspace{0.5cm}
{\large With ZK Proof Verification \& Soft Finality\par}
\vspace{1.5cm}
\begin{tcolorbox}[colback=backcolour,colframe=ghostcyan,width=0.85\textwidth]
\centering
\textbf{Current:} Ethereum (Sepolia) $\leftrightarrow$ Solana (Devnet)\\[0.2cm]
\textbf{Architecture:} Chain-Agnostic, Validium Model\\[0.2cm]
\textbf{Proofs:} Groth16 SNARK + Circle STARK (M31) Hybrid\\[0.2cm]
\textbf{Settlement:} Soft Finality (30s UX, 2-5min crypto finality)\\[0.2cm]
\textbf{Data Layer:} Off-chain (IPFS/Arweave) + State Root on-chain\\[0.2cm]
\textbf{STARK Field:} Mersenne-31 ($2^{31}-1$) for 7-10x faster proving
\end{tcolorbox}
\vspace{1.5cm}
\begin{infobox}[Vision]
A universal payment protocol where users pay with any asset on any chain, recipients receive their desired asset instantly---without trusting centralized intermediaries. Proofs are generated \textbf{before} funds move, not after.
\end{infobox}
\vfill
{\large Version 3.0 --- December 2025\par}
\end{titlepage}

\tableofcontents
\newpage

\section{Overview}

Ghost Protocol is a \textbf{trustless, chain-agnostic cross-chain payment system} enabling instant asset transfers with cryptographic (ZK) proof verification. The architecture supports any EVM chain, Solana, Bitcoin, and future networks.

\subsection{Key Features}
\begin{itemize}[noitemsep]
\item Instant cross-chain payments (10-30 seconds user experience)
\item ZK proof verification (SNARK + STARK hybrid)
\item Multiple liquidity sources (pools, DEXs, stablecoins)
\item Real-time oracle pricing (Pyth Network)
\item Non-custodial (users control their keys)
\item Recursive proof batching for gas efficiency
\item Soft finality with cryptographic guarantees
\end{itemize}

\section{Core Architecture Decisions}

Ghost Protocol makes three fundamental architecture choices that distinguish it from traditional bridges:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Feature} & \textbf{Choice} & \textbf{Rationale} \\
\midrule
Data Storage & Off-Chain (Validium) & On-chain is too expensive \\
Proof Strategy & Recursive Batching & 90-98\% gas reduction \\
Trust Model & Soft Finality & Instant UX with crypto guarantee \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Data Storage: Validium Model}

Storing full transaction history on Ethereum is prohibitively expensive. Ghost Protocol uses the \textbf{Validium} approach:

\begin{archbox}
\begin{verbatim}
VALIDIUM ARCHITECTURE:

+------------------+     +------------------+     +------------------+
|   ETHEREUM       |     |   DA LAYER       |     |   USERS          |
+------------------+     +------------------+     +------------------+
| State Root Only  |<--->| Full History     |<--->| Can Reconstruct  |
| (~32 bytes)      |     | IPFS / Arweave   |     | State Anytime    |
| Cheap to verify  |     | EigenDA / Celestia     | Trustless        |
+------------------+     +------------------+     +------------------+

COST COMPARISON:
  Pure Rollup:     ~$50-100 per tx (calldata)
  Validium:        ~$0.01-0.10 per tx
  Savings:         99%+
\end{verbatim}
\end{archbox}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Approach} & \textbf{Gas Cost} & \textbf{Data Availability} & \textbf{Security} \\
\midrule
Pure Rollup & Very High & Ethereum (best) & Maximum \\
\textbf{Validium} & \textbf{Very Low} & \textbf{DA Layer} & \textbf{High} \\
Volition & Hybrid & User Choice & Flexible \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Why Validium Works:}
\begin{itemize}[noitemsep]
\item State root on Ethereum = cryptographic commitment (cannot be faked)
\item IPFS/Arweave = permanent, verifiable history
\item EigenDA, Celestia = purpose-built DA with economic guarantees
\item Redundancy: Store on 2+ DA layers for safety
\end{itemize}

\subsection{Proof Strategy: Recursive Batching}

Per-transaction proofs on Ethereum mainnet are economically unviable. Recursive batching solves this:

\begin{archbox}
\begin{verbatim}
BATCHING ECONOMICS:

Single Proof:   ~400,000 gas Ã— $0.10 = $40 per tx 
Batch of 50:    ~400,000 gas Ã· 50   = $0.80 per tx 

GAS COST BY BATCH SIZE:
+------------+-------------+-----------------+----------+
| Batch Size | Gas per Tx  | Cost @ 50 gwei  | Savings  |
+------------+-------------+-----------------+----------+
|     1      |   400,000   |     $40.00      |    0%    |
|    10      |    40,000   |      $4.00      |   90%    |
|    50      |     8,000   |      $0.80      |   98%    |
|   100      |     4,000   |      $0.40      |   99%    |
+------------+-------------+-----------------+----------+
\end{verbatim}
\end{archbox}

\textbf{Implementation:}
\begin{lstlisting}
// Batch triggers - submit when EITHER condition met:
const BATCH_CONFIG = {
  maxTxCount: 50,        // Full batch
  maxWaitTime: 30_000,   // 30 seconds (never wait forever)
};
\end{lstlisting}

\begin{successbox}[Recursive Proof Aggregation]
\begin{itemize}[noitemsep]
\item 10-50 individual proofs combined into 1 aggregated proof
\item Verification cost amortized across all transactions
\item User still gets instant settlement (proof exists before funds move)
\item Batch submission happens in background
\end{itemize}
\end{successbox}

\subsection{Trust Model: Soft Finality}

The key insight that enables ``instant ZK'':

\begin{dangerbox}[Critical Distinction]
\textbf{Optimistic:} Execute first, assume valid, allow challenges (7 days). \textbf{No proof exists.}

\textbf{Soft Finality (Ghost):} Generate proof FIRST, release funds, batch proofs later. \textbf{Proof EXISTS before funds move.}
\end{dangerbox}

\begin{archbox}
\begin{verbatim}
SOFT FINALITY TIMELINE:

TIME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>

     |                    RISK WINDOW                    |
     |<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>|
     |                                                   |
 [Deposit]    [Proof Gen]    [SOL Sent]           [Batch Posted]
     |             |              |                      |
   T+0s          T+1s           T+2s                   T+40s
     |             |              |                      |
     v             v              v                      v
  +------+    +--------+    +---------+           +----------+
  | ETH  |    | Proof  |    | User    |           |  HARD    |
  |Locked|    | VALID  |    | Happy   |           | FINALITY |
  +------+    +--------+    +---------+           +----------+

KEY POINT: The proof EXISTS at T+1s.
           It just hasn't been SUBMITTED yet.
           This is NOT optimistic.
\end{verbatim}
\end{archbox}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Aspect} & \textbf{Optimistic Rollup} & \textbf{Ghost Soft Finality} \\
\midrule
Proof at instant moment? & No & \textcolor{ghostgreen}{Yes} \\
Can be proven fraudulent later? & Yes (7 days) & No (already proven) \\
What if challenger appears? & Tx reversed & N/A - already proven \\
Trust assumption & ``Probably valid'' & ``Cryptographically valid'' \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Why This Is NOT Optimistic]
The proof \textbf{exists}. That's the key difference.
\begin{itemize}[noitemsep]
\item Optimistic = No proof exists, trusting it's valid
\item Soft Finality = Proof EXISTS, just not on-chain yet
\item The only deferred action is \textit{posting} the proof, not \textit{generating} it
\end{itemize}
\end{successbox}

\subsection{What We Can Honestly Claim}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Accurate} & \textbf{Misleading} \\
\midrule
``Instant settlement with ZK proof'' & ``On-chain finality in 2 seconds'' \\
``Cryptographically verified before funds release'' & ``Fully trustless instant'' \\
``Proof-first instant transfers'' & ``Zero latency ZK'' \\
``ZK-secured instant payments'' & \\
\bottomrule
\end{tabular}
\end{table}

\section{Centralized vs Decentralized}

\subsection{How Coinbase Works}

\begin{archbox}
\begin{verbatim}
WHAT ACTUALLY HAPPENS ON COINBASE:
  Database: user.eth_balance -= 1.0
  Database: user.usd_balance += 3100.00
  
  (No blockchain transaction!)
  (You hold an IOU, not actual crypto)
\end{verbatim}
\end{archbox}

Coinbase holds licenses (MTL, BitLicense, etc.) but does NOT mint money. They match buyers/sellers internally using customer deposits (\$100B+) and market makers.

\subsection{The Fundamental Trade-off}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Aspect} & \textbf{Coinbase} & \textbf{Ghost} \\
\midrule
Custody & They hold funds & Users hold funds \\
Swaps & Database update & On-chain tx \\
Trust & Trust company & Trust math \\
Freeze funds? & \textcolor{red}{Yes} & \textcolor{ghostgreen}{No} \\
Transparency & Opaque & On-chain \\
\bottomrule
\end{tabular}
\end{table}

\begin{dangerbox}[When Centralized Fails]
FTX (2022): \$8B vanished. Celsius: Froze withdrawals. BlockFi: Bankruptcy. Canada: Government froze accounts.
\end{dangerbox}

\section{Liquidity Architecture}

Ghost Protocol can source liquidity from \textbf{three complementary systems}:

\begin{archbox}
\begin{verbatim}
LIQUIDITY SOURCES
+------------------+  +------------------+  +------------------+
|  GHOST POOLS     |  |  DEX ROUTING     |  |  CIRCLE/USDC     |
|  (Native)        |  |  (Aggregated)    |  |  (Stablecoin)    |
+------------------+  +------------------+  +------------------+
| - Our LP pools   |  | - Uniswap        |  | - USDC minting   |
| - Fast, simple   |  | - Jupiter        |  | - Cross-chain    |
| - Small trades   |  | - 1inch          |  | - Fiat rails     |
| - 0.3% fee       |  | - Large trades   |  | - Institutional  |
+------------------+  +------------------+  +------------------+
        |                    |                      |
        +--------------------+----------------------+
                             |
                    SMART ROUTING ENGINE
                    (Picks best source per trade)
\end{verbatim}
\end{archbox}

\subsection{Option 1: Ghost Native Pools}

Our own liquidity pools on each chain.

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Pros} & \textbf{Considerations} \\
\midrule
Full control & Requires liquidity management \\
Fastest execution & Capital deployment strategy \\
Lowest smart contract risk & Pool rebalancing needed \\
Revenue stays in protocol & Multi-chain coordination \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Best for:} Any trade size (with sufficient pool depth), speed-critical transfers, maximum control.

\subsection{Option 2: DEX Liquidity (Uniswap, Jupiter)}

Route through existing DEX liquidity pools.

\begin{archbox}
\begin{verbatim}
HOW DEX ROUTING WORKS:

User sends 10 ETH
    |
    v
Ghost receives ETH on Ethereum
    |
    v
Ghost mints/bridges wETH to Solana
    |
    v
Jupiter swaps wETH -> SOL (taps $500M+ liquidity)
    |
    v
SOL delivered to recipient
\end{verbatim}
\end{archbox}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Pros} & \textbf{Cons} \\
\midrule
Billions in existing liquidity & Depends on external protocols \\
Better pricing for large trades & Multi-protocol risk \\
No bootstrapping needed & Wrapped assets as intermediate \\
Competitive market = tight spreads & Slippage on huge trades \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Best for:} Large trades over \$10K, price-sensitive users.

\subsubsection{What Do We Lose With DEX Routing?}

\begin{dangerbox}[Honest Trade-offs]
DEX routing is powerful but comes with real costs. Here are the trade-offs:
\end{dangerbox}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Aspect} & \textbf{Ghost Pool} & \textbf{DEX Route} & \textbf{Winner} \\
\midrule
Speed & 10-30 sec & 30-120 sec & Ghost \\
Slippage & Fixed 0.3\% & Variable 0.1-2\% & Ghost \\
Max trade size & Pool limited & Millions & DEX \\
Contract risk & 1 contract & 3-5 contracts & Ghost \\
Failure points & 1 & Multiple & Ghost \\
Revenue & Ghost LPs & External LPs & Ghost \\
Native output & Direct SOL & wETH then swap & Ghost \\
Large trade price & May be worse & Market rate & DEX \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Is DEX Routing Still Instant?}

\textbf{No.} It's \textit{fast} but not instant.

\begin{archbox}
\begin{verbatim}
SPEED COMPARISON:

GHOST POOL PATH (10-30 seconds):
  User pays ETH -> Pool -> SOL sent -> Done
  [=========] 10-30 sec

DEX ROUTE PATH (30-120 seconds):
  User pays ETH -> Bridge wETH -> Jupiter swap -> SOL sent
  [====] 15s    [=======] 30s   [====] 15s    [===] 10s
  Total: 60-120 seconds (2-4x slower)

WHY SLOWER:
1. Bridge step: wETH must reach Solana (~15-30 sec)
2. Swap step: Jupiter execution + confirmation
3. More confirmations: Multiple protocols = more waiting
4. Sequencing: Can't parallelize, must be serial
\end{verbatim}
\end{archbox}

\subsubsection{Other Things We Lose}

\begin{enumerate}
\item \textbf{Predictability} --- Ghost Pool fee is fixed. DEX slippage varies with:
\begin{itemize}[noitemsep]
\item Trade size (bigger = more slippage)
\item Market volatility
\item Available liquidity depth
\item MEV/sandwich attacks
\end{itemize}

\item \textbf{Simplicity} --- More contracts = more things that can break:
\begin{itemize}[noitemsep]
\item Bridge contract (Wormhole, etc.)
\item DEX router contract
\item DEX pool contracts
\item Token contracts (wETH, etc.)
\end{itemize}

\item \textbf{Revenue} --- Fees go to external LPs:
\begin{itemize}[noitemsep]
\item Ghost Pool: 0.2\% to OUR LPs
\item DEX Route: 0.3\% to Uniswap/Jupiter LPs
\item We only keep routing fee (~0.05\%)
\end{itemize}

\item \textbf{User Experience} --- More failure modes:
\begin{itemize}[noitemsep]
\item Bridge congestion
\item DEX liquidity gaps
\item Price movement during multi-step
\item Partial fills possible
\end{itemize}

\item \textbf{Native Assets} --- Extra swap required:
\begin{itemize}[noitemsep]
\item Ghost Pool: ETH in, SOL out (direct)
\item DEX Route: ETH in, wETH bridge, wETH swap, SOL out
\end{itemize}
\end{enumerate}

\subsubsection{When DEX Routing Wins Anyway}

Despite the downsides, DEX routing is better when:

\begin{successbox}[Use DEX When...]
\begin{itemize}[noitemsep]
\item Trade size exceeds Ghost Pool capacity
\item User is price-sensitive (willing to wait for better rate)
\item Ghost Pool is temporarily low on liquidity
\item Trading less common pairs (not ETH/SOL)
\item User explicitly requests market rate
\end{itemize}
\end{successbox}

\subsubsection{The Real Answer: Smart Routing}

\begin{infobox}[Best of Both Worlds]
Don't choose one---use smart routing that picks the best option per trade:
\begin{itemize}[noitemsep]
\item Small + speed-sensitive $\rightarrow$ Ghost Pool
\item Large + price-sensitive $\rightarrow$ DEX
\item Huge trades $\rightarrow$ Split across both
\end{itemize}
Users can also override and choose their preferred path.
\end{infobox}

\subsubsection{DEX Integration Partners}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{DEX} & \textbf{Chain} & \textbf{TVL} & \textbf{Use Case} \\
\midrule
Uniswap & Ethereum & \$5B+ & ETH/USDC swaps \\
Jupiter & Solana & \$500M+ & SOL/USDC swaps \\
Curve & Ethereum & \$2B+ & Stablecoin swaps \\
Raydium & Solana & \$100M+ & SOL pairs \\
1inch & Multi & Aggregator & Best route finding \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Option 3: Circle Partnership (USDC Minting)}

Partner with Circle to use USDC as settlement layer.

\begin{archbox}
\begin{verbatim}
CIRCLE PARTNERSHIP MODEL:

User sends ETH
    |
    v
ETH sold for USD (via Coinbase Prime or similar)
    |
    v
Circle API mints USDC on destination chain
    |
    v
USDC delivered (or swapped to native via DEX)

REQUIREMENTS:
- Business partnership with Circle
- API access (Circle Mint)
- KYC/AML compliance
- Volume commitments
\end{verbatim}
\end{archbox}

\subsubsection{What is a Minting License?}

Circle (issuer of USDC) has regulatory approval to:
\begin{enumerate}[noitemsep]
\item Accept USD deposits
\item Mint equivalent USDC tokens
\item Burn USDC and return USD
\item Operate across multiple chains
\end{enumerate}

\begin{warningbox}[Important Distinction]
Circle does NOT give ``minting licenses'' to third parties. Ghost would need to become a \textbf{Circle Partner} with API access, not receive a license to mint ourselves.
\end{warningbox}

\subsubsection{Circle Partnership Tiers}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Tier} & \textbf{Requirements} & \textbf{Capabilities} \\
\midrule
Basic API & Registration & Read balances, transfers \\
Circle Mint & Business agreement & Mint/burn USDC \\
Strategic Partner & Volume + compliance & Custom integration \\
Co-founder level & Coinbase-tier & Full infrastructure \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Pros} & \textbf{Cons} \\
\midrule
``Unlimited'' liquidity & Centralized dependency \\
Regulatory clarity & Circle can freeze addresses \\
Fiat on/off ramps & Only works for USDC \\
Institutional trust & Business relationship required \\
Multi-chain native USDC & Fees to Circle \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Best for:} Stablecoin transfers, institutional clients, fiat integration.

\subsection{Hybrid Smart Routing}

The optimal approach combines all three:

\begin{archbox}
\begin{verbatim}
SMART ROUTING LOGIC:

if (amount < $1,000):
    use Ghost Pool (fastest, simplest)
    
elif (amount < $50,000):
    compare Ghost Pool vs DEX
    pick best price after fees
    
elif (amount < $500,000):
    split across Ghost Pool + DEX
    minimize slippage
    
else: // whale trade
    use Circle USDC settlement
    or OTC desk
    or multi-DEX split
\end{verbatim}
\end{archbox}

\begin{successbox}[Why Hybrid Wins]
\begin{itemize}[noitemsep]
\item Small trades: Fast via Ghost pools
\item Medium trades: Best price via DEX comparison
\item Large trades: Deep liquidity via aggregation
\item Stablecoins: Native USDC via Circle
\item All trustless except Circle path (optional)
\end{itemize}
\end{successbox}

\section{Architecture}

\begin{archbox}
\begin{verbatim}
+-------------------+     +-------------------+     +-------------------+
|    ETHEREUM       |     |     RELAYER       |     |     SOLANA        |
+-------------------+     +-------------------+     +-------------------+
| Ghost Pool        |<--->| Event Listener    |<--->| SOL Pool          |
| ZK System         |     | ZK Generator      |     | ZK Verifier       |
| Payment Router    |     | Pyth Oracle       |     | Jupiter SDK       |
| Uniswap Router    |     | Smart Routing     |     | Raydium SDK       |
+-------------------+     +-------------------+     +-------------------+
\end{verbatim}
\end{archbox}

\section{Smart Contracts}

\subsection{GhostLiquidityPool.sol}
\textbf{Network:} Sepolia | \textbf{Address:} \texttt{0x3078...8b9}

\subsection{ZKProofSystem.sol}
\textbf{Network:} Sepolia | \textbf{Address:} \texttt{0x3033...cF}

\section{Payment Flow}

\begin{enumerate}
\item \textbf{USER:} Initiates payment with amount + destination
\item \textbf{ROUTER:} Determines optimal liquidity source
\item \textbf{EXECUTION:} Pool, DEX, or Circle path
\item \textbf{ZK PROOFS:} SNARK (deposit) + STARK (transfer)
\item \textbf{SETTLEMENT:} Proofs verified, funds delivered
\end{enumerate}

\section{Zero-Knowledge Proofs: Technical Deep Dive}

Ghost Protocol uses a \textbf{hybrid SNARK + STARK} proving system---a novel combination that leverages the strengths of both to achieve trustless cross-chain verification.

\subsection{Why Zero-Knowledge Proofs?}

Traditional cross-chain bridges rely on:
\begin{itemize}[noitemsep]
\item Trusted validators (centralized, hackable)
\item Multi-sig committees (collusion risk)
\item Optimistic rollups (7-day delays)
\end{itemize}

ZK proofs provide \textbf{mathematical certainty}: a proof that a computation happened correctly, without revealing the inputs, verifiable by anyone in milliseconds.

\subsection{SNARK: Succinct Non-interactive Argument of Knowledge}

\subsubsection{Mathematical Foundation}

SNARKs are built on \textbf{elliptic curve pairings} and \textbf{Quadratic Arithmetic Programs (QAP)}.

\begin{successbox}[SNARK Properties]
\begin{itemize}[noitemsep]
\item \textbf{Succinct:} Proof size is constant (~200-300 bytes)
\item \textbf{Non-interactive:} Single message from prover to verifier
\item \textbf{Verification:} $O(1)$ time (milliseconds)
\item \textbf{Proof generation:} $O(n \log n)$ where $n$ = circuit size
\end{itemize}
\end{successbox}

\subsubsection{The Math: Groth16 Protocol}

Ghost Protocol uses Groth16, the most efficient SNARK construction.

\textbf{Setup Phase (Trusted Setup):}

Given a circuit $C$, generate proving key $pk$ and verification key $vk$:
\begin{align}
pk &= ([\alpha]_1, [\beta]_1, [\beta]_2, [\delta]_1, [\delta]_2, \{[A_i(\tau)]_1\}, \{[B_i(\tau)]_2\}) \\
vk &= ([\alpha]_1, [\beta]_2, [\gamma]_2, [\delta]_2, \{[\frac{\beta \cdot A_i(\tau) + \alpha \cdot B_i(\tau) + C_i(\tau)}{\gamma}]_1\})
\end{align}

Where $[x]_1$ denotes a point on elliptic curve $G_1$, $[x]_2$ on $G_2$.

\textbf{Proof Generation:}

Given witness $w = (w_1, ..., w_m)$, compute proof $\pi = (A, B, C)$:
\begin{align}
A &= [\alpha + \sum_{i=0}^{m} w_i \cdot A_i(\tau) + r \cdot \delta]_1 \\
B &= [\beta + \sum_{i=0}^{m} w_i \cdot B_i(\tau) + s \cdot \delta]_2 \\
C &= [\frac{\sum_{i=\ell+1}^{m} w_i(\beta \cdot A_i(\tau) + \alpha \cdot B_i(\tau) + C_i(\tau))}{\delta} + As + Br - rs\delta]_1
\end{align}

Where $r, s$ are random blinding factors.

\textbf{Verification (The Key Equation):}

The verifier checks:
\begin{equation}
\boxed{e(A, B) = e(\alpha, \beta) \cdot e(\sum_{i=0}^{\ell} w_i \cdot L_i, \gamma) \cdot e(C, \delta)}
\end{equation}

This is a \textbf{bilinear pairing equation}. If it holds, the proof is valid with overwhelming probability.

\subsubsection{Ghost Protocol SNARK Circuit}

Our SNARK proves: \textit{``A deposit of $X$ ETH was made at block $B$ to address $A$ on Ethereum.''}

\begin{archbox}
\begin{verbatim}
SNARK CIRCUIT (Deposit Proof):

PUBLIC INPUTS:
  - commitment_hash: H(amount, recipient, block, nonce)
  - ethereum_state_root: Merkle root of Ethereum state
  
PRIVATE INPUTS (Witness):
  - amount: 0.01 ETH (in wei)
  - recipient: Solana address (32 bytes)
  - block_number: 18234567
  - nonce: random 256-bit value
  - merkle_proof: path from tx to state root

CONSTRAINTS:
  1. commitment_hash == Poseidon(amount, recipient, block, nonce)
  2. MerkleVerify(tx_hash, merkle_proof, state_root) == true
  3. amount > 0
  4. amount <= pool_balance
\end{verbatim}
\end{archbox}

\textbf{Circuit Size:} ~50,000 constraints \\
\textbf{Proof Size:} 192 bytes (3 group elements) \\
\textbf{Verification Gas:} ~200,000 gas on Ethereum

\subsection{STARK: Scalable Transparent Argument of Knowledge}

\subsubsection{Mathematical Foundation}

STARKs use \textbf{hash functions} and \textbf{polynomial IOPs} (Interactive Oracle Proofs), avoiding elliptic curves entirely.

\begin{successbox}[STARK Properties]
\begin{itemize}[noitemsep]
\item \textbf{Transparent:} No trusted setup required
\item \textbf{Quantum-resistant:} Based on hash functions, not EC
\item \textbf{Scalable:} Verification time $O(\log^2 n)$
\item \textbf{Proof size:} Larger (~45-200 KB)
\end{itemize}
\end{successbox}

\subsubsection{Circle STARKs: The M31 Optimization}

Ghost Protocol uses \textbf{Circle STARKs} with the Mersenne-31 field---a critical optimization that provides 7-10x faster proving than traditional STARKs.

\begin{infobox}[Why Circle STARKs?]
Traditional STARKs use large prime fields (252-256 bits) requiring expensive bignum arithmetic. Circle STARKs use the Mersenne prime $2^{31} - 1$, which fits perfectly in 32-bit CPU registers.
\end{infobox}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Feature} & \textbf{Traditional STARK} & \textbf{Circle STARK (M31)} \\
\midrule
Field Size & 252-256 bits & 31 bits \\
Arithmetic & Bignum (slow) & Native 32-bit (fast) \\
Proving Speed & ~10-30 seconds & ~1-3 seconds \\
Verification Cost & ~500K compute units & ~50-100K compute units \\
Memory Usage & 4-8 GB & 500MB-1GB \\
\bottomrule
\end{tabular}
\end{table}

\textbf{The Mersenne-31 Prime:}
\begin{equation}
p = 2^{31} - 1 = 2,147,483,647
\end{equation}

This prime is special because:
\begin{enumerate}[noitemsep]
\item It fits exactly in a 32-bit signed integer
\item Modular reduction is just bit operations (no division):
\begin{equation}
x \mod (2^{31} - 1) = (x \land \texttt{0x7FFFFFFF}) + (x \gg 31)
\end{equation}
\item Field multiplication is a single CPU multiply instruction
\item SIMD vectorization achieves massive parallelism
\end{enumerate}

\begin{archbox}
\begin{verbatim}
M31 FIELD OPERATIONS (Native CPU Speed):

TRADITIONAL (256-bit):
  a Ã— b = bignum_multiply(a, b)     // Multiple cycles
  result = bignum_mod(product, p)   // Division required
  
M31 (32-bit):
  product = (uint64_t)a * b;        // ONE instruction
  result = (product & 0x7FFFFFFF) + (product >> 31);
  if (result >= p) result -= p;     // Simple compare
  
SPEEDUP: 10-50x per field operation
\end{verbatim}
\end{archbox}

\subsubsection{The Math: FRI Protocol}

STARKs use the \textbf{Fast Reed-Solomon Interactive Oracle Proof (FRI)} for polynomial commitment.

\textbf{Algebraic Intermediate Representation (AIR):}

A computation is expressed as polynomial constraints over a trace:
\begin{equation}
\forall i \in [0, T): \quad C(s_i, s_{i+1}) = 0
\end{equation}

Where $s_i$ is the state at step $i$, and $C$ is the constraint polynomial.

\textbf{Low-Degree Extension:}

The execution trace is interpolated into a polynomial $P(x)$ of degree $< n$, then evaluated over a larger domain $D$ (typically $8n$ points).

\textbf{FRI Commitment:}

The prover commits to $P(x)$ using Merkle trees:
\begin{align}
\text{commit}(P) &= \text{MerkleRoot}(\{P(\omega^i) : i \in D\}) \\
\omega &= \text{primitive root of unity in } \mathbb{F}_{2^{31}-1}
\end{align}

\textbf{FRI Folding (The Key Insight):}

Repeatedly ``fold'' the polynomial to prove it has low degree:
\begin{equation}
P_{i+1}(x) = \frac{P_i(x) + P_i(-x)}{2} + \alpha_i \cdot \frac{P_i(x) - P_i(-x)}{2x}
\end{equation}

After $\log n$ rounds, the final polynomial is constant (degree 0), proving the original was low-degree.

\subsubsection{Circle STARK Implementation}

Ghost Protocol uses \textbf{Plonky3} (Polygon's M31 prover) or \textbf{Stwo} (StarkWare's M31 prover):

\begin{archbox}
\begin{verbatim}
// Circle STARK proof generation (Rust/Plonky3)
use plonky3::field::mersenne31::Mersenne31;
use plonky3::stark::Stark;

fn prove_sol_transfer(
    sol_amount: u64,
    recipient: [u8; 32],
    slot: u64,
    signature: [u8; 64],
) -> CircleStarkProof {
    let trace = build_execution_trace(sol_amount, recipient, slot);
    
    // M31 field operations - native CPU speed
    let proof = Stark::<Mersenne31>::prove(
        &transfer_air,
        &trace,
        &public_inputs,
    );
    
    // Proving time: ~1-3 seconds (vs 10-30s traditional)
    proof
}
\end{verbatim}
\end{archbox}

\subsubsection{Ghost Protocol STARK Circuit (M31)}

Our Circle STARK proves: \textit{``Y SOL was transferred to address $A$ on Solana.''}

\begin{archbox}
\begin{verbatim}
CIRCLE STARK CIRCUIT (Transfer Proof over M31 Field):

PUBLIC INPUTS:
  - transfer_commitment: H(sol_amount, recipient, slot, sig)
  - solana_bank_hash: Solana's bank hash at slot
  
PRIVATE INPUTS (Witness):
  - sol_amount: 0.4985 SOL (in lamports)
  - recipient: Solana pubkey
  - slot_number: 298765432
  - transaction_signature: 64 bytes
  - account_proof: Merkle path in Solana's account tree

CONSTRAINTS (evaluated over F_{2^31-1}):
  1. transfer_commitment == Poseidon_M31(sol_amount, recipient, slot, sig)
  2. AccountProofVerify(account, proof, bank_hash) == true
  3. sol_amount == eth_amount * exchange_rate * (1 - fee)
  4. signature_valid(sig, tx_data, relayer_pubkey)

FIELD: Mersenne-31 (p = 2^31 - 1)
HASH: Poseidon optimized for M31
\end{verbatim}
\end{archbox}

\textbf{Trace Length:} ~100,000 rows \\
\textbf{Proof Size:} ~50 KB \\
\textbf{Proving Time:} ~1-3 seconds (7-10x faster than traditional) \\
\textbf{Verification Time:} ~10ms (off-chain), ~50-100K compute units (Solana)

\subsection{Hybrid Approach: Why Both?}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Property} & \textbf{SNARK (Groth16)} & \textbf{STARK (Circle/M31)} & \textbf{Ghost Hybrid} \\
\midrule
Proof Size & ~200 bytes & ~50 KB & 200 B + 50 KB \\
Verification & O(1) & O(logÂ² n) & O(1) on EVM \\
Trusted Setup & Required & \textcolor{ghostgreen}{None} & Partial \\
Quantum Safe & No & \textcolor{ghostgreen}{Yes} & Defense in depth \\
Proving Speed & ~5-10 sec & \textcolor{ghostgreen}{~1-3 sec (M31)} & Fast \\
Best For & EVM verification & Solana compute & Both chains \\
\bottomrule
\end{tabular}
\end{table}

\begin{infobox}[Ghost's Novel Hybrid: Groth16 + Circle STARK]
\textbf{SNARK (Groth16) for Ethereum:}
\begin{itemize}[noitemsep]
\item Cheap on-chain verification (~200K gas)
\item Tiny proof size (192 bytes)
\item EVM has native pairing precompiles
\end{itemize}

\textbf{Circle STARK (M31) for Solana:}
\begin{itemize}[noitemsep]
\item No trusted setup required
\item Quantum-resistant (hash-based)
\item 7-10x faster proving with Mersenne-31 field
\item Solana's compute model handles larger proofs efficiently
\end{itemize}

\textbf{Combined commitment (ghost\_id)} ties both proofs cryptographically.
\end{infobox}

\subsubsection{Why Not Use the Same Proof System for Both?}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Option} & \textbf{Problem} & \textbf{Why We Don't} \\
\midrule
SNARK everywhere & Trusted setup for both & Single ceremony = single point of failure \\
STARK everywhere & 50KB proof on EVM & Too expensive (~2M gas) \\
\textbf{Hybrid} & \textbf{None} & \textbf{Best of both worlds} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{The Cryptographic Binding}

The proofs are \textbf{cryptographically linked} via a shared commitment:

\begin{equation}
\text{ghost\_id} = \text{Poseidon}(\text{snark\_commitment} \| \text{stark\_commitment} \| \text{nonce})
\end{equation}

This ensures:
\begin{enumerate}[noitemsep]
\item The same funds can't be claimed twice (no double-spend)
\item The source and destination are atomically linked
\item Tampering with either proof invalidates the ghost\_id
\end{enumerate}

\subsection{Verification Flow}

\begin{archbox}
\begin{verbatim}
COMPLETE ZK VERIFICATION FLOW:

1. USER DEPOSITS (Ethereum)
   |
   v
2. SNARK GENERATED
   - Proves: "0.01 ETH deposited in block 18234567"
   - Input: tx_hash, merkle_proof, amount, recipient
   - Output: proof_snark (192 bytes), commitment_snark
   |
   v
3. RELAYER TRANSFERS (Solana)
   |
   v
4. STARK GENERATED
   - Proves: "0.4985 SOL sent to recipient in slot 298765432"
   - Input: tx_sig, account_proof, amount, exchange_rate
   - Output: proof_stark (50 KB), commitment_stark
   |
   v
5. PROOFS SUBMITTED TO POOL CONTRACT
   - submitSNARKProof(ghost_id, proof_snark, commitment_snark)
   - submitSTARKProof(ghost_id, proof_stark, commitment_stark)
   |
   v
6. ON-CHAIN VERIFICATION
   - Verify SNARK: pairing check (200K gas)
   - Verify STARK commitment hash (50K gas)
   - Check: ghost_id == H(commitment_snark || commitment_stark)
   |
   v
7. SETTLEMENT FINALIZED
   - Payment intent marked "ZK Verified"
   - Funds released from pool
   - LP shares updated
\end{verbatim}
\end{archbox}

\subsection{Security Properties}

\begin{successbox}[Cryptographic Guarantees]
\begin{enumerate}[noitemsep]
\item \textbf{Soundness:} False proofs are computationally infeasible to create
\item \textbf{Zero-Knowledge:} Verifier learns nothing beyond validity
\item \textbf{Non-malleability:} Proofs cannot be modified without detection
\item \textbf{Extractability:} Valid proof implies prover knows the witness
\end{enumerate}
\end{successbox}

\textbf{Concrete Security:}
\begin{itemize}[noitemsep]
\item SNARK soundness: $2^{-128}$ (128-bit security)
\item STARK soundness: $2^{-80}$ to $2^{-128}$ (configurable)
\item Hash collision resistance: $2^{-256}$ (Poseidon)
\end{itemize}

\subsection{Novelty: What Makes Ghost Unique}

\begin{dangerbox}[Prior Art Limitations]
\begin{itemize}[noitemsep]
\item \textbf{zkSync/StarkNet:} Single-chain ZK rollups, not cross-chain
\item \textbf{Wormhole/LayerZero:} Multi-sig validators, not ZK
\item \textbf{Succinct/Polymer:} ZK light clients, but high latency
\item \textbf{Across Protocol:} Optimistic with challenge period
\item \textbf{Other ZK bridges:} Traditional STARKs (10-30 sec proving vs our 1-3 sec)
\end{itemize}
\end{dangerbox}

\begin{successbox}[Ghost Protocol Innovations]
\begin{enumerate}
\item \textbf{Groth16 + Circle STARK (M31) Hybrid:} First cross-chain bridge using M31 field
   \begin{itemize}[noitemsep]
   \item SNARK (Groth16): Cheap EVM verification (200K gas)
   \item Circle STARK (M31): 7-10x faster proving, quantum-resistant
   \item Chain-optimized: Right proof system for each chain's constraints
   \end{itemize}

\item \textbf{Sub-Second STARK Proving:} M31 field enables near-instant proofs
   \begin{itemize}[noitemsep]
   \item Traditional STARK: 10-30 seconds
   \item Circle STARK: 1-3 seconds
   \item Soft finality becomes truly ``instant''
   \end{itemize}

\item \textbf{Instant Settlement with ZK:} Proof exists before funds move
   \begin{itemize}[noitemsep]
   \item Not optimistic (no challenge period)
   \item Not trusted (no validator set)
   \item Mathematically verified before transfer
   \end{itemize}

\item \textbf{Efficient Recursive Batching:} M31 makes aggregation fast
   \begin{itemize}[noitemsep]
   \item 50 proofs aggregated in 2-5 minutes (was 25 min)
   \item 90-98\% gas savings
   \item No user-perceived delay
   \end{itemize}

\item \textbf{Liquidity Pool + ZK:} Novel combination
   \begin{itemize}[noitemsep]
   \item Pool enables instant liquidity
   \item ZK ensures trustless settlement
   \item LPs protected by cryptographic proofs
   \end{itemize}

\item \textbf{Chain-Agnostic Design:} Same framework, optimized per chain
   \begin{itemize}[noitemsep]
   \item EVM chains: Groth16 SNARK (native pairing)
   \item Solana: Circle STARK (M31 compute-efficient)
   \item Future chains: Add appropriate verifier
   \end{itemize}
\end{enumerate}
\end{successbox}

\subsection{Implementation: Proof Generation Code}

\begin{archbox}
\begin{verbatim}
// SNARK Proof Generation (Circom + SnarkJS - Groth16)
async function generateSNARKProof(deposit) {
  const input = {
    amount: BigInt(deposit.amount),
    recipient: poseidonHash(deposit.solanaRecipient),
    blockNumber: deposit.blockNumber,
    nonce: randomBytes(32),
    merkleProof: await getMerkleProof(deposit.txHash)
  };
  
  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    input,
    "circuits/deposit.wasm",
    "circuits/deposit_final.zkey"
  );
  
  return {
    proofId: keccak256(publicSignals[0]),
    proof: packProof(proof),  // 192 bytes
    commitment: publicSignals[0]
  };
}

// CIRCLE STARK Proof Generation (Plonky3 / Stwo - M31 Field)
async function generateCircleSTARKProof(transfer) {
  // Using Mersenne-31 field for 7-10x speedup
  const trace = buildM31ExecutionTrace({
    solAmount: transfer.amount,
    recipient: transfer.recipient,
    slot: transfer.slot,
    signature: transfer.signature,
    exchangeRate: transfer.rate
  });
  
  // Plonky3 M31 prover - native 32-bit operations
  const proof = await plonky3Prover.prove(
    transferCircuit,  // AIR constraints over F_{2^31-1}
    trace,
    { field: "mersenne31" }
  );
  
  // Proving time: ~1-3 seconds (was 10-30 seconds)
  return {
    proofId: keccak256(proof.commitment),
    proof: proof.serialize(),  // ~50KB
    commitment: proof.commitment
  };
}
\end{verbatim}
\end{archbox}

\subsubsection{M31 Field Operations (Why It's Fast)}

\begin{archbox}
\begin{verbatim}
// Traditional STARK field operation (256-bit)
function fieldMul_traditional(a, b, p) {
  const product = bignum.multiply(a, b);  // Expensive
  return bignum.mod(product, p);          // Division required
}

// Circle STARK M31 field operation (32-bit)
function fieldMul_m31(a, b) {
  const P = 0x7FFFFFFF;  // 2^31 - 1
  const product = BigInt(a) * BigInt(b);
  
  // Reduction without division!
  let result = Number((product & BigInt(P)) + (product >> 31n));
  if (result >= P) result -= P;
  
  return result;  // Single CPU cycle
}

// SIMD vectorized (8 operations at once)
function fieldMul_m31_simd(a_vec, b_vec) {
  // Process 8 field multiplications in parallel
  return _mm256_mul_epu32(a_vec, b_vec);  // AVX2 instruction
}
\end{verbatim}
\end{archbox}

\subsection{Gas Costs and Optimization}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Operation} & \textbf{Ethereum Gas} & \textbf{Solana CU} & \textbf{Optimization} \\
\midrule
SNARK verification & ~200,000 & N/A & EVM pairing precompile \\
STARK commitment & ~50,000 & ~50-100K & M31 hash verification \\
Ghost ID binding & ~30,000 & ~10K & Single Poseidon hash \\
State update & ~40,000 & ~5K & Efficient storage \\
\textbf{Total per payment} & \textbf{~320K} & \textbf{~70K} & \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Circle STARK Performance Gains}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Metric} & \textbf{Traditional STARK} & \textbf{Circle STARK (M31)} \\
\midrule
Proving time & 10-30 seconds & \textcolor{ghostgreen}{1-3 seconds} \\
Solana verification & ~500K compute units & \textcolor{ghostgreen}{~50-100K CU} \\
Memory for proving & 4-8 GB & \textcolor{ghostgreen}{500MB-1GB} \\
Batch of 50 proofs & 15-25 minutes & \textcolor{ghostgreen}{2-5 minutes} \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Why M31 Matters for Ghost Protocol]
\begin{itemize}[noitemsep]
\item \textbf{Soft finality is faster:} Proof generation in 1-3 sec means user gets funds faster
\item \textbf{Batching is practical:} 50 proofs in 2-5 min instead of 25 min
\item \textbf{Solana verification is cheap:} 5-10x reduction in compute units
\item \textbf{Memory efficient:} Can run on commodity hardware
\end{itemize}
\end{successbox}

\begin{infobox}[Proof Aggregation with M31]
Batch multiple payments into a single proof:
\begin{itemize}[noitemsep]
\item 50 payments $\rightarrow$ 1 aggregated SNARK (Ethereum)
\item 50 Circle STARKs $\rightarrow$ 1 recursive proof (Solana)
\item Gas per payment: 320K $\rightarrow$ ~10K
\item M31 makes aggregation 7-10x faster than traditional
\end{itemize}
\end{infobox}

\section{Pricing}

\textbf{Oracle:} Pyth Network (real-time)

\begin{equation}
\text{Output} = \text{Input} \times \frac{\text{Input\_USD}}{\text{Output\_USD}} \times (1 - \text{fee})
\end{equation}

\section{Fee Structure}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Path} & \textbf{Fee} & \textbf{Split} & \textbf{Speed} \\
\midrule
Ghost Pool & 0.3\% & 0.1\% protocol, 0.2\% LP & Fastest \\
DEX Route & 0.3\% + DEX fee & Protocol + DEX LPs & Medium \\
Circle USDC & 0.1\% + Circle fee & Protocol + Circle & Varies \\
\bottomrule
\end{tabular}
\end{table}

\section{Risk Management}

\subsection{Insurance Fund Model}

\begin{itemize}[noitemsep]
\item 0.1\% of every transaction to Insurance Fund
\item Covers oracle failures, relayer defaults, edge cases
\item Balance visible on-chain, DAO-controlled
\item Grows with protocol usage
\end{itemize}

\subsection{Path-Specific Risks}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Path} & \textbf{Risk} & \textbf{Mitigation} \\
\midrule
Ghost Pool & Pool liquidity & Insurance fund \\
DEX Route & Smart contract (multi) & Audited DEXs only \\
Circle & Centralized, freezing & Optional path, disclosed \\
\bottomrule
\end{tabular}
\end{table}

\begin{infobox}[Transparency Principle]
Users always see which path their transaction takes. Circle path clearly labeled as ``centralized but regulated.'' DEX path shows which protocols involved.
\end{infobox}

\section{Security Analysis: Risk Windows \& Mitigations}

The soft finality model creates a \textbf{risk window} between instant delivery and on-chain settlement. This section analyzes all attack vectors and their mitigations.

\subsection{Risk Window Timeline}

\begin{archbox}
\begin{verbatim}
TIME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>

     |                    RISK WINDOW                    |
     |<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>|
     |                                                   |
 [Deposit]    [Proof Gen]    [SOL Sent]           [Batch Posted]
     |             |              |                      |
   T+0s          T+1s           T+2s                   T+40s

WHAT'S PROVEN AT T+1s:
  âœ“ The transaction is valid
  âœ“ The amounts are correct
  âœ“ The cryptographic proof exists

WHAT REQUIRES TRUST (until batch):
  â³ That the relayer will submit the batch

MITIGATION:
  ðŸ’° Relayer has staked collateral
  âš¡ Escape hatch lets users force-submit
  ðŸ“œ Proof is exportable
\end{verbatim}
\end{archbox}

\subsection{Risk 1: Relayer Disappears After Sending SOL}

\begin{archbox}
\begin{verbatim}
SCENARIO:
â”œâ”€â”€ User deposits ETH âœ“
â”œâ”€â”€ Relayer generates proof âœ“
â”œâ”€â”€ Relayer sends SOL to recipient âœ“
â”œâ”€â”€ Relayer goes offline forever âœ—
â””â”€â”€ Batch never submitted to Ethereum âœ—

RESULT:
â€¢ Recipient: Has SOL âœ“ (happy)
â€¢ User: ETH in contract
â€¢ Relayer: Lost SOL, never reclaimed ETH
\end{verbatim}
\end{archbox}

\textbf{Risk Level:} Medium \\
\textbf{Who Loses:} Relayer (they sent SOL but cannot prove it on-chain) \\
\textbf{Mitigations:}
\begin{itemize}[noitemsep]
\item Proof is exportable --- user or anyone can submit it
\item Escape hatch after timeout allows forced settlement
\item Relayer collateral covers losses
\item Multiple relayer redundancy
\end{itemize}

\subsection{Risk 2: Ethereum Reorg After Instant Release}

\begin{dangerbox}[High Risk If Not Mitigated]
If Ethereum reorganizes and the deposit transaction disappears, the relayer has sent SOL for a non-existent deposit.
\end{dangerbox}

\begin{archbox}
\begin{verbatim}
SCENARIO:
â”œâ”€â”€ User deposits ETH (block 1000)
â”œâ”€â”€ Relayer sees deposit, generates proof
â”œâ”€â”€ Relayer sends SOL instantly
â”œâ”€â”€ Ethereum reorgs, block 1000 replaced
â”œâ”€â”€ User's deposit TX no longer exists
â””â”€â”€ Proof references non-existent state

RESULT:
â€¢ Recipient: Has SOL âœ“
â€¢ User: Got refunded ETH (reorg) âœ“
â€¢ Relayer: Lost SOL, proof is orphaned âœ—
\end{verbatim}
\end{archbox}

\textbf{Risk Level:} High (if not mitigated) \\
\textbf{Who Loses:} Relayer \\
\textbf{Mitigation:}
\begin{lstlisting}
// Wait for Ethereum finality before releasing SOL
const REQUIRED_CONFIRMATIONS = 12; // ~3 minutes

// Or use finalized block (post-merge Ethereum)
const block = await provider.getBlock('finalized');
\end{lstlisting}

\begin{successbox}[Safe Instant Model]
Wait for 2-3 Ethereum confirmations (~30-45 seconds) before releasing SOL. This reduces reorg risk to near-zero while maintaining ``near-instant'' UX.
\end{successbox}

\subsection{Risk 3: Relayer Submits Fake Proof}

\begin{archbox}
\begin{verbatim}
SCENARIO:
â”œâ”€â”€ User deposits ETH
â”œâ”€â”€ Relayer claims to generate proof (doesn't)
â”œâ”€â”€ Relayer sends SOL anyway
â”œâ”€â”€ Batch time comes...
â”œâ”€â”€ Relayer has no valid proof to submit
â””â”€â”€ On-chain verification fails

RESULT:
â€¢ Recipient: Has SOL âœ“ (can't be clawed back)
â€¢ User: ETH stuck or returned?
â€¢ Relayer: Can't prove the transfer happened
\end{verbatim}
\end{archbox}

\textbf{Risk Level:} Critical (if not mitigated) \\
\textbf{Who Loses:} Relayer and system integrity \\
\textbf{Mitigation:}
\begin{lstlisting}
// Users/watchers can verify proof BEFORE trusting
async function verifyProofLocally(proof, publicInputs) {
  const isValid = await snarkjs.groth16.verify(
    vkey, publicInputs, proof
  );
  if (!isValid) throw new Error("INVALID - DO NOT TRUST");
  return true;
}
\end{lstlisting}

\subsection{Risk 4: Double Spend via Race Condition}

This is the most critical attack vector. It occurs when multiple relayers process the same deposit.

\begin{dangerbox}[Critical Risk]
If multiple relayers see the same deposit and all send SOL, the recipient gets multiple payouts for a single deposit.
\end{dangerbox}

\begin{archbox}
\begin{verbatim}
THE ATTACK SCENARIO:

                         TIME
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>
    
    Block 1000: User deposits 1 ETH to Ghost Pool
                        |
                        v
         +--------------+--------------+
         |                             |
         v                             v
    +---------+                   +---------+
    |Relayer A|                   |Relayer B|
    | Tokyo   |                   | NYC     |
    +---------+                   +---------+
         |                             |
         | Sees deposit                | Sees deposit
         | at T+100ms                  | at T+150ms
         |                             |
         v                             v
    Generate proof                Generate proof
         |                             |
         v                             v
    Send 40 SOL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Send 40 SOL
    to recipient                 to recipient
         |                             |
         v                             v
    +â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+
    |  RECIPIENT NOW HAS 80 SOL           |
    |  BUT ONLY 1 ETH WAS DEPOSITED       |
    +â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+
\end{verbatim}
\end{archbox}

\subsubsection{Attack Variations}

\textbf{Variation 1: Multiple Honest Relayers (Accident)}

In a decentralized relayer network, all relayers see the same deposit event simultaneously. Each tries to help, resulting in multiple payouts.

\textbf{Variation 2: Malicious User Exploits Latency}
\begin{archbox}
\begin{verbatim}
USER (Attacker):
â”œâ”€â”€ Deposit 1 ETH
â”œâ”€â”€ Immediately send "process" request to 10 relayers
â”œâ”€â”€ Each relayer thinks they're first
â”œâ”€â”€ Collect 10x SOL
â””â”€â”€ Profit: 9 ETH worth of SOL
\end{verbatim}
\end{archbox}

\textbf{Variation 3: MEV / Front-Running}
\begin{archbox}
\begin{verbatim}
BLOCK N:
â”œâ”€â”€ User's deposit TX in mempool
â”œâ”€â”€ MEV bot sees it
â”œâ”€â”€ MEV bot spins up 5 "relayer" instances
â”œâ”€â”€ Each instance fires SOL the moment deposit confirms
â””â”€â”€ All 5 fire simultaneously
\end{verbatim}
\end{archbox}

\subsubsection{Solutions}

\textbf{Solution 1: Single Relayer (Centralized)}

Only ONE authorized relayer processes deposits.

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Pros} & \textbf{Cons} \\
\midrule
No double-spend possible & Single point of failure \\
Simple implementation & Not decentralized \\
 & Trust assumption \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Verdict:} Works for MVP but defeats decentralization goals.

\textbf{Solution 2: On-Chain Lock Before Release}

\begin{lstlisting}[language=Solidity]
contract GhostPool {
    mapping(bytes32 => address) public depositClaims;
    
    // Step 1: Relayer claims the deposit on-chain FIRST
    function claimDeposit(bytes32 depositHash) external {
        require(depositClaims[depositHash] == address(0), 
                "Already claimed");
        depositClaims[depositHash] = msg.sender;
        emit DepositClaimed(depositHash, msg.sender);
    }
    
    // Step 2: Only the claimer can process it
    function executeDeposit(
        bytes32 depositHash, 
        bytes calldata proof
    ) external {
        require(depositClaims[depositHash] == msg.sender, 
                "Not your claim");
        // Process...
    }
}
\end{lstlisting}

\begin{archbox}
\begin{verbatim}
FLOW:
1. Deposit happens
2. Relayer sends TX: claimDeposit(hash) 
3. Wait for claim TX to confirm (12 sec)
4. Only winner can process
5. Winner sends SOL
6. Winner submits proof in batch

TRADE-OFF: Adds 12+ seconds latency
\end{verbatim}
\end{archbox}

\textbf{Verdict:} Safe but slower.

\textbf{Solution 3: Deterministic Leader Election}

\begin{archbox}
\begin{verbatim}
RELAYER CONSENSUS PROTOCOL:

1. Deposit event detected by all relayers

2. Relayers run leader election:
   - Hash(depositHash + relayerPubkey + blockHash)
   - Lowest hash = leader

3. Leader has 10 seconds to process

4. If leader fails, next-lowest takes over

5. Other relayers WATCH, don't act
\end{verbatim}
\end{archbox}

\begin{lstlisting}
// Deterministic leader election
function electLeader(depositHash, blockHash, relayers) {
  const scores = relayers.map(r => ({
    relayer: r,
    score: keccak256(depositHash + r.pubkey + blockHash)
  }));
  
  scores.sort((a, b) => a.score.localeCompare(b.score));
  return scores[0].relayer; // Deterministic winner
}

// All relayers compute the same leader
const leader = electLeader(deposit.hash, block.hash, relayers);

if (leader.pubkey === myPubkey) {
  await processDeposit(deposit); // I'm the leader
} else {
  await watchForCompletion(deposit, leader); // Just watch
}
\end{lstlisting}

\textbf{Verdict:} Best balance of decentralization and safety.

\textbf{Solution 4: On-Chain Nonce (Recommended)}

\begin{lstlisting}[language=Solidity]
contract GhostPool {
    mapping(bytes32 => bool) public processedDeposits;
    
    function processDeposit(
        bytes32 depositHash,
        bytes calldata proof
    ) external onlyRelayer {
        // THE KEY LINE
        require(!processedDeposits[depositHash], 
                "Already processed");
        processedDeposits[depositHash] = true;
        
        require(verifyProof(proof), "Invalid proof");
        emit DepositProcessed(depositHash, recipient, solAmount);
    }
}
\end{lstlisting}

\begin{archbox}
\begin{verbatim}
HOW IT WORKS:

Relayer A sends processDeposit TX â”€â”€â”€â”€> âœ“ Succeeds (first)
Relayer B sends processDeposit TX â”€â”€â”€â”€> âœ— Reverts (nonce set)
Relayer C sends processDeposit TX â”€â”€â”€â”€> âœ— Reverts (nonce set)

Relayer A sends SOL â”€â”€â”€â”€> âœ“ Valid
Relayer B sees A succeeded â”€â”€â”€â”€> STOP Aborts SOL send
Relayer C sees A succeeded â”€â”€â”€â”€> STOP Aborts SOL send

The race condition is moved ON-CHAIN where Ethereum's 
consensus resolves it. Whoever's TX gets included first wins.
\end{verbatim}
\end{archbox}

\textbf{Verdict:} Simple, battle-tested pattern used by MEV bots and liquidation systems.

\subsubsection{Double-Spend Solution Summary}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Approach} & \textbf{Safe?} & \textbf{Latency} & \textbf{Decentralized?} \\
\midrule
Single relayer & Yes & 0 sec & No \\
On-chain claim first & Yes & +12-15 sec & Yes \\
Leader election & Yes & +1-2 sec & Yes \\
On-chain nonce & Yes & 0 sec* & Yes \\
\bottomrule
\end{tabular}
\end{table}

*Nonce requires claim TX before SOL send, but adds no user-perceived latency.

\subsection{Defense in Depth}

\begin{archbox}
\begin{verbatim}
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+
|                    SECURITY LAYERS                               |
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+
|                                                                  |
|  Layer 1: WAIT FOR FINALITY                                      |
|  +â”€â”€ 12+ confirmations on Ethereum                               |
|  +â”€â”€ Eliminates reorg risk                                       |
|                                                                  |
|  Layer 2: ON-CHAIN NONCES                                        |
|  +â”€â”€ Each deposit gets unique ID                                 |
|  +â”€â”€ Prevents double-processing                                  |
|                                                                  |
|  Layer 3: LOCAL PROOF VERIFICATION                               |
|  +â”€â”€ Recipients/watchers verify before trusting                  |
|  +â”€â”€ Catches fake proofs                                         |
|                                                                  |
|  Layer 4: ESCAPE HATCH                                           |
|  +â”€â”€ User can force-submit after timeout                         |
|  +â”€â”€ Handles relayer failure                                     |
|                                                                  |
|  Layer 5: SLASHABLE COLLATERAL                                   |
|  +â”€â”€ Relayer stakes funds                                        |
|  +â”€â”€ Economic guarantee of honesty                               |
|                                                                  |
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€+
\end{verbatim}
\end{archbox}

\subsection{Complete Risk Matrix}

\begin{table}[h]
\centering
\small
\begin{tabular}{llllll}
\toprule
\textbf{Risk} & \textbf{Prob.} & \textbf{Impact} & \textbf{Who Loses} & \textbf{Mitigation} \\
\midrule
Relayer offline & Low & Medium & Relayer & Escape hatch, collateral \\
Ethereum reorg & Low & High & Relayer & Wait for finality \\
Fake proof & Low* & Critical & Everyone & Local verification \\
Double spend & Medium & Critical & System & On-chain nonces \\
Solana failure & Low & Medium & User & Retry logic \\
DA layer down & Very Low & Low & History & Multi-DA redundancy \\
\bottomrule
\end{tabular}
\end{table}

*Low if relayer is honest; higher if adversarial.

\subsection{Recommended Production Configuration}

\begin{successbox}[Safe Instant Model]
\begin{enumerate}
\item Wait for 2-3 Ethereum confirmations (~30-45 sec)
   \begin{itemize}[noitemsep]
   \item Reduces reorg risk to near-zero
   \end{itemize}

\item Generate ZK proof
   \begin{itemize}[noitemsep]
   \item Cryptographic validity established
   \end{itemize}

\item Publish proof hash publicly (IPFS/API)
   \begin{itemize}[noitemsep]
   \item Anyone can verify before trusting
   \end{itemize}

\item Send SOL to recipient
   \begin{itemize}[noitemsep]
   \item Recipient can verify proof first if paranoid
   \end{itemize}

\item Batch proofs to chain within 5 minutes
   \begin{itemize}[noitemsep]
   \item Short window = minimal risk exposure
   \end{itemize}
\end{enumerate}

\textbf{Result:} ``Near-instant'' (45 sec) with minimal risk.
\end{successbox}

\begin{infobox}[Phased Decentralization]
\textbf{MVP:} Single trusted relayer with on-chain nonce safety net. Fast, simple.

\textbf{Production:} Primary relayer cluster with backup set using leader election.

\textbf{Mature:} Open relayer network with consensus protocol, slashing, and reputation.
\end{infobox}

\section{Business Model: Three Strategic Paths}

Ghost Protocol can operate with three distinct liquidity strategies. Each can work standalone or in combination.

\subsection{Path 1: Native Ghost Pools (Decentralized)}

\begin{infobox}[Ghost Pool Model]
Build and maintain proprietary liquidity pools on each supported chain.
\end{infobox}

\subsubsection{How It Works}
\begin{enumerate}[noitemsep]
\item LPs deposit native assets (ETH, SOL, etc.) into Ghost pools
\item Users pay into source pool, receive from destination pool
\item ZK proofs verify each transaction
\item Fees distributed to LPs proportionally
\end{enumerate}

\subsubsection{Revenue Model}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Fee Type} & \textbf{Rate} & \textbf{Recipient} & \textbf{Purpose} \\
\midrule
Transaction Fee & 0.30\% & Split & Total fee charged \\
$\rightarrow$ Protocol & 0.10\% & Ghost Treasury & Operations, dev \\
$\rightarrow$ LP Rewards & 0.20\% & Liquidity Providers & Yield for LPs \\
Insurance Fund & 0.02\% & Reserve & Risk coverage \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Unit Economics}

\begin{archbox}
\begin{verbatim}
MONTHLY VOLUME: $10M

Revenue Breakdown:
  Transaction fees (0.30%):     $30,000
  - Protocol share (0.10%):     $10,000  <- Ghost revenue
  - LP rewards (0.20%):         $20,000  <- To depositors
  - Insurance (0.02%):          $2,000   <- Reserve

LP Returns (assuming $2M TVL):
  Annual yield: ($20,000 Ã— 12) / $2M = 12% APY

Break-even Analysis:
  Minimum monthly volume for sustainability: ~$3M
\end{verbatim}
\end{archbox}

\subsubsection{Pros and Cons}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Advantages} & \textbf{Challenges} \\
\midrule
Full control over liquidity & Requires active management \\
All fees stay in ecosystem & Multi-chain coordination \\
Truly decentralized & Pool rebalancing needed \\
Scales to any trade size & \\
Best UX (fastest) & Requires active LP management \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Best For]
Any trade size with sufficient pool depth, maximum speed and control, keeping all revenue in-protocol.
\end{successbox}

\subsection{Path 2: DEX Aggregation (Leverage Existing Liquidity)}

\begin{infobox}[DEX Router Model]
Route through existing DEX liquidity (Uniswap, Jupiter, etc.) instead of maintaining own pools.
\end{infobox}

\subsubsection{How It Works}
\begin{enumerate}[noitemsep]
\item User initiates cross-chain payment
\item Ghost bridges wrapped asset to destination chain
\item Jupiter/Uniswap swaps to native asset
\item Recipient receives desired token
\end{enumerate}

\subsubsection{Revenue Model}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Fee Type} & \textbf{Rate} & \textbf{Recipient} & \textbf{Notes} \\
\midrule
Routing Fee & 0.05-0.10\% & Ghost Protocol & Our cut \\
DEX Swap Fee & 0.30\% & DEX LPs & Uniswap/Jupiter \\
Bridge Fee & 0.10\% & Bridge protocol & Wormhole/etc \\
\textbf{Total User Cost} & \textbf{0.45-0.50\%} & Various & Higher than Pool \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Unit Economics}

\begin{archbox}
\begin{verbatim}
MONTHLY VOLUME: $10M

Revenue (Ghost keeps routing fee only):
  Routing fee (0.08%):          $8,000   <- Ghost revenue

Comparison to Pool Model:
  Pool model revenue:           $10,000
  DEX model revenue:            $8,000
  Difference:                   -20% revenue

BUT: No capital requirements!
  Pool model needs $2M+ TVL
  DEX model needs $0 TVL

Capital Efficiency:
  Pool: $10K revenue / $2M capital = 0.5% monthly return on capital
  DEX:  $8K revenue / $0 capital = infinite return on capital
\end{verbatim}
\end{archbox}

\subsubsection{Pros and Cons}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Advantages} & \textbf{Challenges} \\
\midrule
No capital requirements & Lower margins \\
Infinite liquidity depth & Slower (30-120 sec) \\
Proven DEX security & Dependent on external protocols \\
Easy to launch & Variable slippage \\
Handles large trades & Multiple failure points \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Best For]
Large trades (\$50K+), capital-light launch, maximum liquidity depth, price-sensitive users.
\end{successbox}

\subsection{Path 3: Circle Partnership (USDC Settlement)}

\begin{infobox}[Circle CCTP Model]
Partner with Circle to use USDC as settlement layer with mint/burn capabilities.
\end{infobox}

\subsubsection{How It Works}
\begin{enumerate}[noitemsep]
\item User pays in any asset
\item Ghost converts to USDC (via DEX if needed)
\item Circle CCTP burns USDC on source chain
\item Circle mints USDC on destination chain
\item Ghost converts USDC to recipient's desired asset
\end{enumerate}

\subsubsection{Revenue Model}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Fee Type} & \textbf{Rate} & \textbf{Recipient} & \textbf{Notes} \\
\midrule
Conversion Fee & 0.10\% & Ghost Protocol & In/out of USDC \\
Circle CCTP & 0.00\% & Circle & Currently free \\
Swap fees (if any) & 0.30\% & DEX LPs & Only if not USDC \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Unit Economics}

\begin{archbox}
\begin{verbatim}
MONTHLY VOLUME: $10M (assume 50% already USDC)

USDC-to-USDC transfers ($5M):
  Conversion fee:               $0       (no conversion needed)
  Protocol fee (0.05%):         $2,500   <- Ghost revenue

Non-USDC transfers ($5M):
  Conversion fee (0.10%):       $5,000   <- Ghost revenue
  DEX fees:                     $15,000  <- To external LPs

Total Ghost Revenue:            $7,500

Advantage: Institutional trust
  - Circle is regulated (NYDFS, etc.)
  - Banks can participate
  - Compliance-friendly
\end{verbatim}
\end{archbox}

\subsubsection{Pros and Cons}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Advantages} & \textbf{Challenges} \\
\midrule
No liquidity needed & Centralized (Circle controls) \\
Institutional trust & USDC can be frozen \\
Regulatory compliance & Requires partnership \\
Unlimited scale & Limited to Circle-supported chains \\
Stablecoin focus & Extra swap for non-USDC \\
\bottomrule
\end{tabular}
\end{table}

\begin{warningbox}[Centralization Trade-off]
Circle can freeze USDC addresses. This path trades decentralization for institutional access and regulatory clarity.
\end{warningbox}

\begin{successbox}[Best For]
Institutional clients, regulated environments, stablecoin-heavy use cases, enterprise integrations.
\end{successbox}

\subsection{Path 4: Hybrid Model (Recommended)}

\begin{infobox}[Smart Routing Hybrid]
Combine all three paths with intelligent routing based on trade characteristics.
\end{infobox}

\subsubsection{Routing Logic}

\begin{archbox}
\begin{verbatim}
SMART ROUTER DECISION TREE:

Input: trade_amount, speed_preference, user_type

if (trade_amount < $10K AND speed_preference == "instant"):
    -> GHOST POOL (fastest, 10-30 sec)
    
elif (trade_amount > $50K):
    -> DEX ROUTE (deepest liquidity)
    
elif (user_type == "institutional" OR compliance_required):
    -> CIRCLE USDC (regulated path)
    
elif (asset == USDC AND destination_has_CCTP):
    -> CIRCLE USDC (native, no conversion)
    
else:
    -> Compare Pool vs DEX, pick best rate
    
User can always override with manual path selection.
\end{verbatim}
\end{archbox}

\subsubsection{Revenue Optimization}

\begin{table}[h]
\centering
\begin{tabular}{lllll}
\toprule
\textbf{Trade Type} & \textbf{Path} & \textbf{Ghost Fee} & \textbf{Speed} & \textbf{Why} \\
\midrule
\$500 ETH$\rightarrow$SOL & Pool & 0.10\% & 15 sec & Fast, simple \\
\$100K ETH$\rightarrow$SOL & DEX & 0.08\% & 90 sec & Depth needed \\
\$50K USDC$\rightarrow$USDC & Circle & 0.05\% & 60 sec & Native path \\
\$25K institutional & Circle & 0.10\% & 60 sec & Compliance \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Hybrid Unit Economics}

\begin{archbox}
\begin{verbatim}
MONTHLY VOLUME: $10M (distributed across paths)

Volume Distribution (optimized):
  Ghost Pool (40%):    $4M   @ 0.10% = $4,000
  DEX Route (35%):     $3.5M @ 0.08% = $2,800
  Circle USDC (25%):   $2.5M @ 0.07% = $1,750

Total Ghost Revenue:   $8,550/month

Compared to single-path:
  Pool-only:           $10,000 (but needs $2M+ capital)
  DEX-only:            $8,000  (no capital needed)
  Circle-only:         $7,500  (needs partnership)
  HYBRID:              $8,550  (balanced, resilient)

Key Advantage: Resilience
  - Pool drained? Fall back to DEX
  - DEX congested? Use Pool or Circle
  - Circle issues? Decentralized paths available
\end{verbatim}
\end{archbox}

\subsection{Strategic Recommendation}

\begin{successbox}[Phased Approach]
\textbf{Phase 1 (Launch):} Ghost Pool only
\begin{itemize}[noitemsep]
\item Simplest to implement
\item Full control
\item Bootstrap with protocol-owned liquidity
\end{itemize}

\textbf{Phase 2 (Scale):} Add DEX routing
\begin{itemize}[noitemsep]
\item Handle overflow volume
\item Large trade support
\item No additional capital needed
\end{itemize}

\textbf{Phase 3 (Scale):} Deep liquidity pools + smart routing
\begin{itemize}[noitemsep]
\item Scale native pools to handle any trade size
\item Smart routing to DEX when optimal
\item Multi-chain pool coordination
\end{itemize}

\textbf{Phase 4 (Optional):} Circle partnership
\begin{itemize}[noitemsep]
\item For institutional clients requiring regulated path
\item Stablecoin optimization for USDC flows
\item Not required---fully optional addition
\end{itemize}

\textbf{Phase 4 (Mature):} Full hybrid with smart routing
\begin{itemize}[noitemsep]
\item Automatic path optimization
\item Maximum resilience
\item Best user experience
\end{itemize}
\end{successbox}

\subsection{Standalone Path Viability}

Each path can work independently:

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Path} & \textbf{Viable Alone?} & \textbf{Min Volume} & \textbf{Capital Needed} \\
\midrule
Ghost Pool & Yes & \$3M/month & \$1-5M TVL \\
DEX Route & Yes & \$5M/month & \$0 \\
Circle USDC & Yes & \$10M/month & Partnership \\
Hybrid & Best & \$2M/month & Flexible \\
\bottomrule
\end{tabular}
\end{table}

\section{LP Economics Deep Dive}

\subsection{Revenue for Ghost Pool LPs}
\begin{itemize}[noitemsep]
\item 0.2\% of Ghost Pool transactions
\item Priority for small/fast trades
\item Liquidity mining rewards (optional)
\item Auto-compounding fees
\end{itemize}

\subsection{LP Yield Scenarios}

\begin{archbox}
\begin{verbatim}
YIELD BY VOLUME (assuming $2M TVL):

Monthly Volume    LP Fees (0.2%)    Annual APY
-------------------------------------------------
$5M               $10,000           6.0%
$10M              $20,000           12.0%
$20M              $40,000           24.0%
$50M              $100,000          60.0%

Comparison to DeFi yields:
  Aave USDC:      3-5% APY
  Uniswap ETH:    5-15% APY
  Ghost Pool:     6-60% APY (volume dependent)
\end{verbatim}
\end{archbox}

\subsection{TradFi Integration Path}

\begin{archbox}
\begin{verbatim}
INSTITUTIONAL ONBOARDING:

1. CUSTODY SETUP
   Bank Treasury -> Qualified Custodian (Fireblocks/Anchorage)
   
2. LIQUIDITY DEPLOYMENT
   Option A: Ghost LP Pool (earn 6-24% yield)
   Option B: Circle Partnership (regulatory comfort)
   Option C: Both (diversified exposure)
   
3. COMPLIANCE LAYER
   - KYC/AML on large deposits
   - Jurisdiction restrictions
   - Audit trail via ZK proofs
   
4. REPORTING
   - Real-time dashboard
   - Monthly statements
   - Tax documentation
\end{verbatim}
\end{archbox}

\subsection{LP Tiers}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Tier} & \textbf{Minimum} & \textbf{Fee Share} & \textbf{Benefits} \\
\midrule
Retail & 0.1 ETH & 0.20\% & Standard access \\
Professional & 10 ETH & 0.22\% & Governance voting \\
Institutional & 100 ETH & 0.25\% & Priority support, API \\
Strategic & 1000 ETH & 0.30\% & Revenue share, board seat \\
\bottomrule
\end{tabular}
\end{table}

\section{Competitive Analysis}

\begin{table}[h]
\centering
\small
\begin{tabular}{lllll}
\toprule
Protocol & Speed & Trust & Liquidity & Native \\
\midrule
\textbf{Ghost} & 10-30s & Trustless & Multi-source & Yes \\
Wormhole & 15-20s & 19 guardians & Own pools & No \\
LayerZero & 1-5min & Oracle & Partner & No \\
Across & Instant* & 7-day & Own pools & Yes \\
Circle CCTP & Minutes & Circle & Mint/burn & USDC only \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Ghost Advantages}

\begin{enumerate}[noitemsep]
\item \textbf{Multi-source liquidity:} Not limited to own pools
\item \textbf{Native ZK proofs:} Trustless, not optimistic
\item \textbf{Flexible paths:} Trustless or regulated (user choice)
\item \textbf{Chain-agnostic:} Add chains with adapters
\end{enumerate}

\section{Circle Partnership Path}

\subsection{How to Partner with Circle}

\begin{enumerate}
\item \textbf{Apply:} Circle Partner Program application
\item \textbf{Compliance:} KYC/AML program, legal review
\item \textbf{Technical:} API integration, security audit
\item \textbf{Business:} Volume commitments, fee structure
\item \textbf{Launch:} Staged rollout with monitoring
\end{enumerate}

\subsection{What Circle Partnership Enables}

\begin{itemize}[noitemsep]
\item Native USDC on 15+ chains (no wrapping)
\item Cross-Chain Transfer Protocol (CCTP)
\item Fiat on/off ramps for institutional clients
\item Regulatory cover for compliant path
\item Marketing co-promotion
\end{itemize}

\begin{warningbox}[Circle is Not Trustless]
Circle partnership adds a \textbf{regulated, centralized} option. Users who want fully trustless can use Ghost Pools or DEX routes. Transparency about trade-offs is key.
\end{warningbox}

\section{Running the System}

\begin{lstlisting}
# Relayer (with DEX routing)
node scripts/instant-relayer.mjs

# Dashboard
cd dashboard && npm run dev

# Deploy
npx hardhat compile
node scripts/deploy-pools.mjs --seed
\end{lstlisting}

\section{Payment API \& SDK}

Ghost Protocol exposes APIs for third-party integrations, enabling any platform to accept cross-chain payments.

\subsection{Transaction Speed Metrics}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Metric} & \textbf{Time} & \textbf{What It Means} \\
\midrule
User-perceived speed & 5-10 sec & SOL lands in recipient wallet \\
Soft finality & 5-10 sec & ZK proof generated (cryptographic guarantee) \\
Hard finality & 30-45 sec & ZK proof verified on-chain \\
\bottomrule
\end{tabular}
\end{table}

\begin{infobox}[Key Differentiator]
The ZK proof EXISTS before funds move. Even though on-chain verification takes 30-45 seconds, the cryptographic guarantee is established at 5-10 seconds. This is NOT optimistic---reversal is mathematically impossible once the proof is generated.
\end{infobox}

\subsection{REST API Endpoints}

\begin{archbox}
\begin{verbatim}
POST /api/v1/payments
  Create a payment intent
  Request:  { amount, fromChain, toChain, recipient, metadata }
  Response: { paymentId, depositAddress, expiresAt, estimatedDelivery }

GET /api/v1/payments/{id}
  Get payment status
  Response: { status, timestamps, zkProofs, solanaSignature }

GET /api/v1/payments/{id}/proof
  Get ZK proof details
  Response: { snarkProof, starkProof, ghostId, verifiedAt }

POST /api/v1/webhooks
  Register webhook for payment updates
  Events: payment.pending, payment.completed, payment.failed

GET /api/v1/rates
  Get current exchange rates (via Pyth oracle)
  Response: { ethUsd, solUsd, ethSol, updatedAt }
\end{verbatim}
\end{archbox}

\subsection{SDK Integration (Conceptual)}

\begin{lstlisting}[language=JavaScript]
// NFT Platform Integration Example
import { GhostPayments } from '@ghost-protocol/sdk';

const ghost = new GhostPayments({ apiKey: 'gp_live_xxx' });

// Create payment for NFT purchase
const payment = await ghost.createPayment({
  amount: '0.1',              // ETH
  fromChain: 'ethereum',
  toChain: 'solana',
  recipient: 'ErAUyiSW...gGrc',
  metadata: { 
    orderId: 'nft-123',
    itemName: 'Cool NFT #42'
  }
});

// Show deposit address to user
console.log(`Send ETH to: ${payment.depositAddress}`);
console.log(`Expires: ${payment.expiresAt}`);

// Listen for completion (webhook or polling)
ghost.on('payment.completed', async (event) => {
  console.log(`Payment complete in ${event.deliveryTime}ms`);
  console.log(`Solana TX: ${event.solanaSignature}`);
  console.log(`ZK Proofs: SNARK ${event.snarkVerified}, STARK ${event.starkVerified}`);
  
  // Mint NFT, update order, etc.
  await mintNFT(event.metadata.orderId, event.recipient);
});
\end{lstlisting}

\subsection{Use Cases}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Platform} & \textbf{Flow} & \textbf{Benefit} \\
\midrule
NFT Marketplace & Pay ETH $\rightarrow$ Receive NFT on Solana & Cross-chain purchases \\
Gaming & Buy credits with ETH $\rightarrow$ Solana game & Unified game economy \\
E-commerce & Pay crypto $\rightarrow$ Merchant receives SOL & Lower fees than cards \\
Remittances & Send ETH $\rightarrow$ Family receives SOL & 5-10 sec, not 3-5 days \\
DeFi & Cross-chain yield $\rightarrow$ Auto-compound & Capital efficiency \\
\bottomrule
\end{tabular}
\end{table}

\section{Competitive Analysis}

\subsection{Speed Comparison}

\begin{table}[h]
\centering
\begin{tabular}{lllll}
\toprule
\textbf{Bridge} & \textbf{Delivery} & \textbf{Finality Type} & \textbf{Reversal Risk} & \textbf{ZK Proof} \\
\midrule
\textbf{Ghost Protocol} & \textcolor{ghostgreen}{5-10 sec} & ZK (30-45s hard) & None* & \textcolor{ghostgreen}{Yes (M31)} \\
LayerZero & 2-5 min & Oracle consensus & None & No \\
Wormhole & 3-7 min & Guardian signatures & None & No \\
Across & 45 sec & Optimistic & \textcolor{ghostred}{Yes (2hr)} & No \\
Stargate & 1-3 min & LayerZero oracles & None & No \\
Hop Protocol & 1-10 min & Bonder + AMM & None & No \\
\bottomrule
\end{tabular}
\end{table}

*Proof exists before transfer, making reversal cryptographically impossible

\subsection{Technical Comparison}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Metric} & \textbf{Ghost Protocol} & \textbf{LayerZero} & \textbf{Wormhole} \\
\midrule
Trust model & Cryptographic (ZK) & 2/3 oracle consensus & 13/19 guardians \\
Verification & On-chain ZK proof & Off-chain oracles & Off-chain guardians \\
Proof type & SNARK + M31 STARK & None & None \\
Data availability & Validium (off-chain) & N/A & N/A \\
Finality guarantee & Mathematical & Economic (oracle stake) & Economic (guardian stake) \\
Challenge period & None needed & None & None \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Why Ghost Protocol Wins]
\begin{enumerate}[noitemsep]
\item \textbf{Fastest delivery:} 5-10 seconds vs 2-7 minutes
\item \textbf{True finality:} ZK proof, not oracle/guardian trust
\item \textbf{No clawback:} Unlike Across, no challenge window
\item \textbf{M31 STARKs:} 7-10x faster proving than competitors
\item \textbf{Non-custodial:} Users control keys throughout
\end{enumerate}
\end{successbox}

\subsection{Analytics Dashboard Metrics}

For transparency and credibility, Ghost Protocol exposes real-time metrics:

\begin{archbox}
\begin{verbatim}
GHOST PROTOCOL - LIVE METRICS DASHBOARD

SPEED METRICS
+------------------+------------------+------------------+
|  Avg Delivery    |  Avg ZK Proof    |  Hard Finality   |
|     7.2 sec      |    +28.4 sec     |    35.6 sec      |
+------------------+------------------+------------------+

VOLUME (24H)
+------------------+------------------+------------------+
|  Transactions    |  Volume (USD)    |  Fees Earned     |
|     12,847       |    $1.2M         |    $3,600        |
+------------------+------------------+------------------+

ZK PROOF STATS
+------------------+------------------+------------------+
|  SNARK Gen       |  STARK Gen (M31) |  Success Rate    |
|    4.2 sec       |     1.8 sec      |    100%          |
+------------------+------------------+------------------+

LIVE TRANSACTION FEED
| Time  | From        | To          | Amount    | Speed   | Status    |
|-------|-------------|-------------|-----------|---------|-----------|
| 12:34 | 0x7d12...   | ErAUyi...   | 0.5 ETH   | 6.2s    | ZK Verified |
| 12:33 | 0x3a8f...   | 9kPqRt...   | 1.0 ETH   | 8.1s    | ZK Verified |
| 12:32 | 0xb2c1...   | HnYp7s...   | 0.1 ETH   | 5.9s    | ZK Verified |

COMPETITOR COMPARISON (Real-time)
| Bridge           | Avg Speed  | Our Advantage           |
|------------------|------------|-------------------------|
| Ghost Protocol   | 7.2 sec    | --                      |
| LayerZero        | 180 sec    | 25x faster              |
| Wormhole         | 300 sec    | 42x faster              |
| Across           | 45 sec     | 6x faster + no clawback |
\end{verbatim}
\end{archbox}

\section{Roadmap}

\begin{enumerate}[noitemsep]
\item Mainnet launch (ETH + SOL)
\item Payment API \& SDK release
\item Scale native pools (target: \$10M+ TVL per chain)
\item Analytics dashboard (public metrics)
\item DEX integration (Uniswap, Jupiter) for smart routing
\item Bidirectional flows (SOL to ETH)
\item Multi-asset support (USDC, USDT, wBTC)
\item Bitcoin integration
\item zkVM migration (Risc0/SP1) for unified architecture
\item Circle partnership (optional, for institutional clients)
\end{enumerate}

\section{Summary}

\begin{successbox}[Ghost Protocol: Architecture Summary]
\textbf{Core Design Decisions:}
\begin{itemize}[noitemsep]
\item \textbf{Validium Model:} Off-chain data, on-chain state roots (99\% cost reduction)
\item \textbf{Recursive Batching:} 10-50 proofs aggregated (90-98\% gas savings)
\item \textbf{Soft Finality:} Proof exists before funds move (NOT optimistic)
\end{itemize}

\textbf{Liquidity Sources:}
\begin{itemize}[noitemsep]
\item \textbf{Ghost Pools:} Fast, trustless, any trade size with deep pools
\item \textbf{DEX Routing:} Smart routing when optimal pricing available
\item \textbf{Circle (optional):} Regulated path for institutional clients
\end{itemize}

\textbf{Security Model:}
\begin{itemize}[noitemsep]
\item \textbf{On-chain nonces:} Prevent double-spend attacks
\item \textbf{Confirmation waiting:} Eliminate reorg risk
\item \textbf{Escape hatch:} Users can force-submit if relayer fails
\item \textbf{Slashable collateral:} Economic guarantees
\end{itemize}

\textbf{Honest Claims:}
\begin{itemize}[noitemsep]
\item ``Instant ZK'' = Proof exists before funds move, batched later
\item User-perceived: 30-45 seconds
\item Cryptographic finality: 2-5 minutes
\item This is NOT optimistic (proof is generated, not assumed)
\end{itemize}
\end{successbox}

\vfill
\begin{center}
\textit{Version 3.0 --- December 2025}
\end{center}

\section{Technical Critique \& FAQ}

This section addresses common questions and critiques from security researchers and engineers reviewing the Ghost Protocol architecture.

\subsection{Novelty Assessment}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Component} & \textbf{Novelty Level} & \textbf{Rationale} \\
\midrule
SNARK+STARK Hybrid & High & First chain-specific ZK optimization \\
Ghost ID Binding & High & Novel cross-primitive commitment \\
Liquidity Meta-Routing & Medium & Trust-model routing, not just price \\
Instant Settlement & Medium & UX instant, crypto finality delayed \\
Pool + DEX + Circle & Medium & Solves cold-start problem \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Why SNARK for Ethereum, STARK for Solana?}

\begin{infobox}[Chain-Specific Optimization]
Most ZK bridges force one proof system everywhere. Ghost Protocol treats chains \textbf{asymmetrically} based on their constraints:
\end{infobox}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Chain} & \textbf{Constraint} & \textbf{Our Solution} \\
\midrule
Ethereum & Gas-constrained & Groth16 SNARK (192 bytes, 200K gas) \\
Solana & Compute-capable, storage-expensive & STARK (no trusted setup, hash-based) \\
\bottomrule
\end{tabular}
\end{table}

\textbf{The Innovation:}
\begin{itemize}[noitemsep]
\item Ethereum verification must be cheap $\rightarrow$ SNARKs have O(1) verification
\item Solana can handle hashing throughput $\rightarrow$ STARKs leverage this
\item No single ``Trusted Setup Ceremony'' controls both chains
\item Each chain uses its optimal proof system
\end{itemize}

\subsection{Q\&A: Hard Questions}

\subsubsection{Q: Is 10-30 Second Settlement Actually Possible?}

\begin{warningbox}[Honest Answer]
\textbf{User-perceived:} Yes, 10-30 seconds. \\
\textbf{Cryptographic finality:} No, 2-5 minutes.
\end{warningbox}

\begin{archbox}
\begin{verbatim}
WHAT "INSTANT" ACTUALLY MEANS:

User Timeline:
  0 sec   - User pays ETH
  12 sec  - Relayer detects (1 Ethereum block)
  25 sec  - User receives SOL
  [USER IS DONE - "INSTANT" FROM THEIR POV]

Background Settlement:
  +30 sec - SNARK proof generated
  +60 sec - STARK proof generated
  +90 sec - Proofs submitted to contracts
  +120 sec - On-chain verification
  [CRYPTOGRAPHIC FINALITY ACHIEVED]

Analogy: Credit cards
  - You get coffee immediately
  - Actual settlement takes 2-3 days
  - Ghost: User gets SOL immediately
  - ZK settlement takes 2-5 minutes
\end{verbatim}
\end{archbox}

\subsubsection{Q: What About Ethereum Re-orgs?}

\begin{dangerbox}[Valid Concern]
If Ethereum re-orgs after the relayer sends SOL, the source transaction disappears. Who loses money?
\end{dangerbox}

\textbf{Answer: The relayer, not the user.}

\begin{itemize}[noitemsep]
\item Relayer waits for 2-3 block confirmations (not true finality)
\item Relayer accepts re-org risk in exchange for speed
\item Insurance fund covers catastrophic re-orgs
\item User experience is protected
\end{itemize}

\textbf{Risk mitigation:}
\begin{enumerate}[noitemsep]
\item Conservative block confirmation (3+ blocks for large amounts)
\item Dynamic confirmation based on transaction size
\item Insurance fund sized to cover 99.9\% of re-org scenarios
\end{enumerate}

\subsubsection{Q: Unit Economics Don't Work for Small Transactions?}

\begin{dangerbox}[The Hard Truth]
\textbf{Correct.} Per-transaction ZK proofs on Ethereum Mainnet are not economically viable for retail-sized transactions.
\end{dangerbox}

\begin{archbox}
\begin{verbatim}
MAINNET COST ANALYSIS:

Transaction: $50 ETH -> SOL
Fee revenue (0.3%):           $0.15
SNARK verification (200K gas): 
  @ 20 gwei:                  $4.00
  @ 50 gwei:                  $10.00

RESULT: Significant loss on small txs

BREAK-EVEN ANALYSIS:
  @ 20 gwei: Transaction must be > $1,300
  @ 50 gwei: Transaction must be > $3,300

SOLUTIONS:
1. Target L2s (Arbitrum, Base, Optimism)
   - Gas is 10-100x cheaper
   - $50 tx becomes profitable

2. Proof Aggregation (batch mode)
   - 100 txs in 1 proof
   - Gas per tx: $10 -> $0.10
   - Trade-off: 5-10 min batching delay

3. High-value focus (institutional)
   - $10K+ transactions
   - $30 fee is 0.3% - acceptable

4. Hybrid: Instant for users, batch proofs
   - User gets SOL in 30 sec
   - Proof submitted in batch later
   - Best of both worlds
\end{verbatim}
\end{archbox}

\begin{successbox}[Recommended Deployment Strategy]
\begin{itemize}[noitemsep]
\item \textbf{Phase 1:} L2 $\leftrightarrow$ Solana (cheap gas, per-tx proofs work)
\item \textbf{Phase 2:} Mainnet with proof aggregation (batched)
\item \textbf{Phase 3:} Mainnet per-tx for high-value ($>$\$5K)
\end{itemize}
\end{successbox}

\subsubsection{Q: What If Circle Blacklists Ghost Protocol?}

\textbf{Risk:} Circle can freeze USDC addresses. If they blacklist Ghost contracts, the Circle path fails.

\textbf{Mitigation:}
\begin{enumerate}[noitemsep]
\item Circle path is \textbf{optional}, not required
\item Traffic automatically routes to Pool or DEX
\item No user funds ever held in Circle's custody
\item Disclosed as centralization trade-off
\end{enumerate}

\textbf{Residual risk:} If 25\% of volume relies on Circle and they act adversarially, that volume is lost. This is accepted in exchange for institutional access.

\subsubsection{Q: How Is the Ghost ID Cryptographically Secure?}

The \texttt{ghost\_id} prevents double-spending across two different cryptographic primitives:

\begin{equation}
\texttt{ghost\_id} = \text{Poseidon}(\texttt{snark\_commitment} \| \texttt{stark\_commitment} \| \texttt{nonce})
\end{equation}

\textbf{Security properties:}
\begin{itemize}[noitemsep]
\item \textbf{Collision resistance:} $2^{-256}$ probability of collision (Poseidon)
\item \textbf{Binding:} Changing either commitment changes the ghost\_id
\item \textbf{Uniqueness:} Each payment has a unique nonce
\item \textbf{Atomicity:} Both proofs must reference the same ghost\_id
\end{itemize}

\begin{archbox}
\begin{verbatim}
ATTACK SCENARIO: Double-Spend Attempt

Attacker tries to:
1. Create valid SNARK for deposit X
2. Create two STARKs for transfer Y and transfer Z
3. Claim both Y and Z on Solana

Why it fails:
- SNARK commits to: (amount, recipient, block, nonce)
- STARK commits to: (sol_amount, recipient, slot, signature)
- ghost_id = H(snark_commit || stark_commit)

If attacker changes STARK (different recipient):
  -> stark_commitment changes
  -> ghost_id changes
  -> Does not match original SNARK's ghost_id
  -> Verification fails

Result: Each deposit can only claim ONE transfer.
\end{verbatim}
\end{archbox}

\subsection{Comparison: Ghost vs. Existing Bridges}

\begin{table}[h]
\centering
\small
\begin{tabular}{llllll}
\toprule
\textbf{Protocol} & \textbf{Proof} & \textbf{Speed} & \textbf{Trust} & \textbf{Liquidity} & \textbf{Cost} \\
\midrule
\textbf{Ghost} & SNARK+STARK & 30s UX & Trustless & Hybrid & Medium \\
Wormhole & None (multi-sig) & 15s & 19 guardians & Own pools & Low \\
LayerZero & None (oracle) & 1-5min & Oracle+Relayer & Partner & Low \\
Across & Optimistic & Instant* & 7-day challenge & Own pools & Low \\
zkBridge & SNARK only & Minutes & Trustless & Limited & High \\
Succinct & Light client & Minutes & Trustless & None & High \\
\bottomrule
\end{tabular}
\end{table}

*Across is ``instant'' but optimistic---funds can be clawed back during challenge period.

\subsection{Strategic Positioning}

\begin{successbox}[Where Ghost Protocol Wins]
\begin{enumerate}
\item \textbf{Any-size instant transfers} \\
   With deep liquidity pools + recursive batching, we handle \$50 to \$50M transfers profitably

\item \textbf{Speed-critical payments} \\
   30-45 second soft finality beats all competitors on user experience

\item \textbf{L2-to-Solana corridor} \\
   Arbitrum/Base/Optimism to Solana with cheap per-tx proofs

\item \textbf{Compliance-sensitive flows} \\
   Circle path for regulated entities needing audit trails

\item \textbf{Cold-start scenarios} \\
   New chains can launch with DEX fallback, no TVL bootstrap needed
\end{enumerate}
\end{successbox}

\begin{warningbox}[Where Ghost Protocol Struggles]
\begin{enumerate}
\item \textbf{Very small retail transactions} \\
   Sub-\$10 transfers may have thin margins even with batching (but still work)

\item \textbf{Speed-critical arbitrage} \\
   MEV bots need sub-second, not 30 seconds

\item \textbf{Chains without STARK verifiers} \\
   Need native STARK support or fallback to SNARK-only
\end{enumerate}
\end{warningbox}

\subsection{Conclusion: Is Ghost Protocol Novel?}

\begin{successbox}[Verdict]
\textbf{Yes, with specific distinction.}

\begin{itemize}
\item \textbf{High Novelty:} The SNARK+STARK hybrid architecture optimized per-chain is genuinely new. No production bridge uses this approach.

\item \textbf{Medium Novelty:} Trust-model routing (Pool/DEX/Circle) is a smart combination of existing primitives.

\item \textbf{Honest Limitation:} ``Instant ZK'' is UX-instant, not crypto-instant. This is acceptable but should be clearly communicated.

\item \textbf{Economic Reality:} Per-tx proofs work on L2s and for high-value. Mainnet retail requires batching.
\end{itemize}

Ghost Protocol is not reinventing bridging. It is \textbf{optimizing bridging} by matching proof systems to chain constraints and routing to trust models.
\end{successbox}

\section{Appendix: Quick Reference}

\subsection{Terminology}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Term} & \textbf{Definition} \\
\midrule
Soft Finality & User receives funds before proof is on-chain \\
Hard Finality & Proof is verified and recorded on-chain \\
Validium & Off-chain data, on-chain state roots \\
Recursive Batching & Combining multiple proofs into one \\
Ghost ID & Cryptographic binding of SNARK + STARK proofs \\
Escape Hatch & User ability to force-submit if relayer fails \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Key Metrics}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
User-perceived settlement & 30-45 seconds \\
Cryptographic finality & 2-5 minutes \\
SNARK proof size & 192 bytes \\
Circle STARK proof size & ~50 KB \\
SNARK proving time & ~5-10 seconds \\
Circle STARK proving time & \textcolor{ghostgreen}{~1-3 seconds (M31)} \\
Verification gas (SNARK) & ~200,000 \\
Verification CU (STARK) & \textcolor{ghostgreen}{~50-100K (M31)} \\
STARK field & Mersenne-31 ($2^{31}-1$) \\
Batching savings & 90-98\% \\
Fee structure & 0.3\% (0.1\% protocol, 0.2\% LP) \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Architecture Decision Record}

\begin{table}[h]
\centering
\small
\begin{tabular}{llll}
\toprule
\textbf{Decision} & \textbf{Choice} & \textbf{Alternative} & \textbf{Rationale} \\
\midrule
Data storage & Validium & Rollup & 99\% cost reduction \\
EVM proof & Groth16 SNARK & STARK & 200K gas vs 2M gas \\
Solana proof & Circle STARK (M31) & Traditional STARK & 7-10x faster proving \\
STARK field & Mersenne-31 & Goldilocks/BN254 & Native 32-bit CPU ops \\
Settlement & Soft finality & Wait for proof & Better UX \\
Batching & Recursive & Per-tx & Gas efficiency \\
Double-spend & On-chain nonce & Single relayer & Decentralized \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Circle STARK vs Traditional STARK}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Aspect} & \textbf{Traditional STARK} & \textbf{Circle STARK (M31)} \\
\midrule
Field & 252-256 bit prime & $2^{31} - 1$ (Mersenne) \\
Arithmetic & Bignum (slow) & Native 32-bit (fast) \\
Proving & 10-30 seconds & 1-3 seconds \\
Verification & ~500K compute units & ~50-100K compute units \\
Memory & 4-8 GB & 500MB-1GB \\
SIMD support & Limited & Excellent (8-wide AVX2) \\
Implementation & Cairo/Stone & Plonky3/Stwo \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Why Ghost Protocol Uses Circle STARKs]
The Mersenne-31 field is not just an optimization---it's what makes ``instant ZK'' practically achievable. With 1-3 second proof generation:
\begin{itemize}[noitemsep]
\item Soft finality feels truly instant
\item Batching doesn't create noticeable delays
\item Commodity hardware can run provers
\item The economic model becomes viable
\end{itemize}
\end{successbox}

\section{Future: zkVM Integration (Risc0/SP1)}

This section outlines the planned evolution of Ghost Protocol's proving infrastructure using zero-knowledge virtual machines.

\subsection{The Problem: STARK vs SNARK Trade-off}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Property} & \textbf{STARK} & \textbf{SNARK} \\
\midrule
Proving speed & Fast (1-3 sec with M31) & Slower (5-10 sec) \\
Proof size & Large (~50 KB) & Tiny (~192 bytes) \\
EVM verification & Expensive (~2M gas, \$50+) & Cheap (~200K gas, \$5) \\
Trusted setup & None & Required \\
\bottomrule
\end{tabular}
\end{table}

\textbf{The dilemma:} We want fast STARK proving but cheap EVM verification.

\subsection{The Solution: SNARK Wrapper (Recursive Proofs)}

\begin{infobox}[What is a Wrapper?]
A SNARK ``wrapper'' is a SNARK proof that says: \textit{``I verified this STARK proof and it is valid.''}

The SNARK wraps around the STARK like an executive summary wraps around a detailed report. Ethereum only needs to verify the small summary, not the full report.
\end{infobox}

\begin{archbox}
\begin{verbatim}
RECURSIVE PROOF FLOW:

Your Logic: "0.01 ETH deposited, send 0.4 SOL"
                    |
                    v
+----------------------------------------------------------+
|  STEP 1: Generate STARK Proof                            |
|  - Uses fast M31 field                                   |
|  - Time: 1-3 seconds                                     |
|  - Output: 50KB proof                                    |
|  - Valid but EXPENSIVE to verify on Ethereum             |
+----------------------------------------------------------+
                    |
                    v
+----------------------------------------------------------+
|  STEP 2: Generate SNARK Wrapper                          |
|  - SNARK proves: "I verified the STARK, it's valid"      |
|  - Time: 2-4 seconds                                     |
|  - Output: 192 bytes                                     |
|  - This is what goes on Ethereum                         |
+----------------------------------------------------------+
                    |
                    v
+----------------------------------------------------------+
|  STEP 3: Verify on Ethereum                              |
|  - Ethereum only sees the tiny SNARK                     |
|  - Cost: 200,000 gas                                     |
|  - Trusts SNARK, which verified the STARK                |
+----------------------------------------------------------+

TOTAL: 4-8 seconds proving, 200K gas verification
BEST OF BOTH WORLDS!
\end{verbatim}
\end{archbox}

\subsection{What Are zkVMs?}

A \textbf{zkVM (Zero-Knowledge Virtual Machine)} automates the entire STARK + SNARK wrapper process:

\begin{archbox}
\begin{verbatim}
TRADITIONAL ZK DEVELOPMENT (Without zkVM):
+----------------------------------------------------------+
|  You must:                                               |
|  - Learn circuit languages (Circom, Cairo)               |
|  - Write STARK circuit manually                          |
|  - Write SNARK wrapper circuit manually                  |
|  - Handle serialization between provers                  |
|  - Debug constraint systems                              |
|                                                          |
|  Time: 8-12 weeks                                        |
|  Difficulty: Requires ZK expertise                       |
+----------------------------------------------------------+

zkVM DEVELOPMENT (With Risc0/SP1):
+----------------------------------------------------------+
|  You just:                                               |
|  - Write normal Rust code                                |
|  - The zkVM handles everything else                      |
|                                                          |
|  Time: 2-3 weeks                                         |
|  Difficulty: Normal programming                          |
+----------------------------------------------------------+
\end{verbatim}
\end{archbox}

\subsection{Risc0 and SP1}

Two production-ready zkVMs that Ghost Protocol may integrate with:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Feature} & \textbf{Risc0} & \textbf{SP1 (Succinct)} \\
\midrule
Language & Rust & Rust \\
Architecture & RISC-V & RISC-V \\
License & Apache 2.0 & MIT / Apache 2.0 \\
Funding & \$40M+ & \$55M+ \\
SNARK wrapper & Built-in (Groth16) & Built-in (Groth16/Plonk) \\
Cloud proving & Yes (Bonsai) & Yes \\
EVM verification & ~200K gas & ~250K gas \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Example: Ghost Protocol Proof in SP1}

\begin{archbox}
\begin{verbatim}
// THE ENTIRE ZK PROOF LOGIC IN RUST

#![no_main]
sp1_zkvm::entrypoint!(main);

pub fn main() {
    // Read inputs
    let deposit_tx_hash: [u8; 32] = sp1_zkvm::io::read();
    let eth_amount: u64 = sp1_zkvm::io::read();
    let sol_recipient: [u8; 32] = sp1_zkvm::io::read();
    let merkle_proof: Vec<[u8; 32]> = sp1_zkvm::io::read();
    let state_root: [u8; 32] = sp1_zkvm::io::read();
    
    // Verify deposit exists in Ethereum state
    let computed_root = verify_merkle(&deposit_tx_hash, &merkle_proof);
    assert_eq!(computed_root, state_root);
    
    // Calculate SOL amount
    let fee = eth_amount * 3 / 1000; // 0.3%
    let sol_amount = (eth_amount - fee) * exchange_rate;
    
    // Commit outputs (these go on-chain)
    sp1_zkvm::io::commit(&deposit_tx_hash);
    sp1_zkvm::io::commit(&sol_amount);
    sp1_zkvm::io::commit(&sol_recipient);
}

// SP1 automatically:
// 1. Generates STARK proof
// 2. Wraps in SNARK
// 3. Ready for Ethereum verification
\end{verbatim}
\end{archbox}

\subsection{Why zkVM Integration Matters}

\begin{successbox}[Benefits of zkVM Migration]
\begin{enumerate}
\item \textbf{Faster Development:} 2-3 weeks vs 8-12 weeks for custom circuits
\item \textbf{Automatic Wrapper:} STARK-to-SNARK handled automatically
\item \textbf{Best Performance:} Fast STARK proving + cheap EVM verification
\item \textbf{Maintainability:} Write normal Rust, not circuit languages
\item \textbf{Flexibility:} Change logic without new trusted setup
\end{enumerate}
\end{successbox}

\subsection{Vendor Considerations}

\begin{warningbox}[Dependency Trade-offs]
Using Risc0 or SP1 creates some vendor dependency:
\begin{itemize}[noitemsep]
\item Our proof format ties to their system
\item We rely on their continued maintenance
\end{itemize}

\textbf{Mitigations:}
\begin{itemize}[noitemsep]
\item Both are open source (Apache 2.0 / MIT)
\item Can self-host provers (no cloud dependency)
\item Can fork code if vendor disappears
\item Our Rust logic is portable between zkVMs
\item Both are well-funded (\$40-55M+)
\end{itemize}
\end{warningbox}

\subsection{Patent Implications}

\begin{infobox}[What's Patentable?]
Using a zkVM does NOT affect Ghost Protocol's patent position:

\textbf{Cannot Patent} (public domain / others' IP):
\begin{itemize}[noitemsep]
\item STARK/SNARK math (academic)
\item zkVM prover implementations
\item RISC-V instruction set
\end{itemize}

\textbf{Can Patent} (Ghost Protocol innovations):
\begin{itemize}[noitemsep]
\item Ghost ID binding mechanism
\item Soft finality settlement model
\item Hybrid liquidity routing (Pool + DEX + Circle)
\item Chain-specific proof optimization architecture
\item Double-spend prevention system
\end{itemize}

Ghost Protocol's innovation is at the \textbf{protocol layer}, not the cryptographic layer. The implementation (zkVM vs custom) doesn't change what's patentable.
\end{infobox}

\subsection{Why STARK Inside SNARK (Not Reverse)}

The wrapping direction matters:

\begin{archbox}
\begin{verbatim}
STARK INSIDE SNARK (Correct):
+-- STARK is FAST to generate (1-3 sec with M31)
+-- STARK is EXPENSIVE to verify on EVM (2M gas)
+-- SNARK is SLOWER to generate (2-4 sec for wrapper)
+-- SNARK is CHEAP to verify on EVM (200K gas)
|
+-- Solution: Generate fast STARK, wrap in SNARK for cheap verify

SNARK INSIDE STARK (Wrong):
+-- Would need to generate slow SNARK first
+-- Then wrap in STARK
+-- Then verify STARK on EVM (2M gas - expensive!)
|
+-- Defeats the purpose: slow + expensive
\end{verbatim}
\end{archbox}

\begin{dangerbox}[Remember]
STARK is the inner proof (fast to generate). SNARK is the outer wrapper (cheap to verify on EVM).
\end{dangerbox}

\subsection{Complete Migration Path}

\subsubsection{Phase 1: Current System (M31 Circle STARKs)}

\begin{archbox}
\begin{verbatim}
+------------------+                    +------------------+
|    ETHEREUM      |                    |     SOLANA       |
+------------------+                    +------------------+
|  SNARK (Groth16) |                    |  STARK (M31)     |
|  5-10 sec prove  |                    |  1-3 sec prove   |
|  200K gas verify |                    |  50-100K CU      |
+------------------+                    +------------------+
         |                                      |
         +----------------+---------------------+
                          |
                     ghost_id binding
                     (links both proofs)

STATUS: Current architecture
M31 FIELD: Using Mersenne-31 for 7-10x faster STARK proving
SOFT FINALITY: Yes - proof exists before funds move
\end{verbatim}
\end{archbox}

\begin{successbox}[Why M31 Circle STARKs Now]
We use Circle STARKs with the Mersenne-31 field from day one because:
\begin{itemize}[noitemsep]
\item 7-10x faster proving (1-3 sec vs 10-30 sec)
\item 5x cheaper Solana verification
\item Native 32-bit CPU operations
\item No additional complexity vs traditional STARKs
\end{itemize}
\end{successbox}

\subsubsection{Phase 2: Unified Architecture with Wrapper (Future)}

\begin{archbox}
\begin{verbatim}
              +--------------------------------+
              |     ONE STARK (M31) CIRCUIT    |
              |     All logic in one place     |
              |     Proving time: 1-3 sec      |
              +---------------+----------------+
                              |
              +---------------+---------------+
              |                               |
              v                               v
    +------------------+            +------------------+
    |   SNARK Wrapper  |            |   STARK Direct   |
    |   (for EVM)      |            |   (for Solana)   |
    |   +2-4 sec       |            |   +0 sec         |
    +--------+---------+            +--------+---------+
             |                               |
             v                               v
    +------------------+            +------------------+
    |    ETHEREUM      |            |     SOLANA       |
    |    200K gas      |            |     50K CU       |
    +------------------+            +------------------+

CHANGE: One unified proof circuit
WRAPPER: STARK wrapped in SNARK for EVM only
SOLANA: Uses STARK directly (no wrapper needed)
SOFT FINALITY: Still works - proof exists before funds move
\end{verbatim}
\end{archbox}

\subsection{Soft Finality Through All Phases}

\begin{successbox}[Key Guarantee]
Soft finality works identically in ALL phases:

\begin{enumerate}[noitemsep]
\item T+0s: User deposits ETH
\item T+1-5s: Proof generated (SNARK, STARK, or wrapped---doesn't matter)
\item T+2-6s: \textbf{Proof EXISTS} --- cryptographically valid
\item T+3-7s: SOL sent to recipient $\leftarrow$ \textbf{User is done}
\item T+40s: Proof batched and submitted on-chain $\leftarrow$ Hard finality
\end{enumerate}

The wrapping approach changes HOW you prove, not WHEN. The proof still exists before funds move.
\end{successbox}

\subsection{Migration Timeline}

\begin{table}[h]
\centering
\begin{tabular}{llll}
\toprule
\textbf{Phase} & \textbf{Architecture} & \textbf{Status} & \textbf{Soft Finality} \\
\midrule
1 (Current) & SNARK (Groth16) + M31 STARK & \textcolor{ghostgreen}{Live} & Works \\
2 (Future) & Unified M31 STARK + wrapper & Planned & Works \\
\bottomrule
\end{tabular}
\end{table}

\begin{successbox}[Current State]
\textbf{We ship with M31 Circle STARKs from day one.} This gives us:
\begin{itemize}[noitemsep]
\item 7-10x faster Solana proving (1-3 sec vs 10-30 sec)
\item 5x cheaper Solana verification
\item No additional implementation complexity
\end{itemize}

\textbf{Phase 1 $\rightarrow$ 2:} Upgrade to unified architecture with SNARK wrapper when we want single codebase. Uses zkVM (Risc0/SP1) for automation.

Soft finality works throughout. The architecture change is an optimization, not a requirement.
\end{successbox}

\end{document}

